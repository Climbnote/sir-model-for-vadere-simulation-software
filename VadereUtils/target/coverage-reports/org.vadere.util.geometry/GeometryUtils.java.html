<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeometryUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">VadereUtils</a> &gt; <a href="index.source.html" class="el_package">org.vadere.util.geometry</a> &gt; <span class="el_source">GeometryUtils.java</span></div><h1>GeometryUtils.java</h1><pre class="source lang-java linenums">package org.vadere.util.geometry;

import java.awt.geom.Path2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.Random;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.vadere.util.geometry.shapes.IPoint;
import org.vadere.util.geometry.shapes.VCircle;
import org.vadere.util.geometry.shapes.VLine;
import org.vadere.util.geometry.shapes.VPoint;
import org.vadere.util.geometry.shapes.VPolygon;
import org.vadere.util.geometry.shapes.VRectangle;
import org.vadere.util.geometry.shapes.VShape;
import org.vadere.util.geometry.shapes.VTriangle;
import org.vadere.util.logging.Logger;
import java.awt.geom.Area;

/**
 * This utility class contains only static methods which are used to solve
 * general geometric problems like line or shape intersections.
 *
 * @author Benedikt Zoennchen
 */
<span class="pc bpc" id="L34" title="1 of 2 branches missed.">public class GeometryUtils {</span>

	/**
	 * Constant for comparison of double values. Everything below this is
	 * considered equal.
	 */
	public static final double DOUBLE_EPS = 1e-11;

<span class="fc" id="L42">	public static final Logger log = Logger.getLogger(GeometryUtils.class);</span>

	public static double lengthSq(double x, double y) {
<span class="nc" id="L45">		return x*x + y*y;</span>
	}

	public static double length(double x, double y) {
<span class="nc" id="L49">		return Math.sqrt(lengthSq(x, y));</span>
	}

	/**
	 * Interpolates between start and end with the given factor i.e. two values at once.
	 *
	 * @param start     the start / min values
	 * @param end       the end / max values times factor
	 * @param factor    the scale of the max value
	 *
	 * @return the two interpolated values (x,y)
	 */
	public static VPoint interpolate(@NotNull final VPoint start, @NotNull final VPoint end, double factor) {
<span class="nc" id="L62">		VPoint result = new VPoint(start.x + factor * (end.x - start.x),</span>
				start.y + factor * (end.y - start.y));
<span class="nc" id="L64">		return result;</span>
	}

	/**
	 * Computes the determinant of a 2x2-matrix.
	 * @param x1    x11 of the matrix
	 * @param y1    x21 of the matrix
	 * @param x2    x21 of the matrix
	 * @param y2    x22 of the matrix
	 * @return
	 */
	public static double det2D(double x1, double y1, double x2, double y2) {
<span class="fc" id="L76">		return x1 * y2 - y1 * x2;</span>
	}

	/**
	 * Determinant of a 3x3-matrix
	 *
	 * @param a
	 * @return
	 */
	public static double det3D(final double[][] a) {
<span class="fc" id="L86">		return a[0][0]*a[1][1]*a[2][2] + a[0][1]*a[1][2]*a[2][0] + a[0][2]*a[1][0]*a[2][1] - a[0][2]*a[1][1]*a[2][0] - a[0][1]*a[1][0]*a[2][2] - a[0][0]*a[1][2]*a[2][1];</span>
	}

	/**
	 * Computes the (optional) intersection point of a {@link VRectangle} boundary and the line-segment defined by ((x1, y1), (x2, y2)).
	 *
	 * @param rectangle the rectangle
	 * @param x1        the x-coordinate of the first point of the line-segment
	 * @param y1        the y-coordinate of the first point of the line-segment
	 * @param x2        the x-coordinate of the second point of the line-segment
	 * @param y2        the y-coordinate of the second point of the line-segment
	 *
	 * @return the intersection point or {@link Optional#empty()}
	 */
	public static Optional&lt;VPoint&gt; intersectionPoint(
			@NotNull final VRectangle rectangle,
			final double x1,
			final double y1,
			final double x2,
			final double y2) {
<span class="nc bnc" id="L106" title="All 2 branches missed.">		if(intersectLineSegment(rectangle.x, rectangle.y, rectangle.x + rectangle.width, rectangle.y, x1, y1, x2, y2)) {</span>
<span class="nc" id="L107">			return Optional.of(intersectionPoint(rectangle.x, rectangle.y, rectangle.x + rectangle.width, rectangle.y, x1, y1, x2, y2));</span>
		}
<span class="nc bnc" id="L109" title="All 2 branches missed.">		else if(intersectLineSegment(rectangle.x, rectangle.y, rectangle.x, rectangle.y + rectangle.height, x1, y1, x2, y2)) {</span>
<span class="nc" id="L110">			return Optional.of(intersectionPoint(rectangle.x, rectangle.y, rectangle.x, rectangle.y + rectangle.height, x1, y1, x2, y2));</span>
		}
<span class="nc bnc" id="L112" title="All 2 branches missed.">		else if(intersectLineSegment(rectangle.x + rectangle.width, rectangle.y, rectangle.x + rectangle.width, rectangle.y + rectangle.height, x1, y1, x2, y2)) {</span>
<span class="nc" id="L113">			return Optional.of(intersectionPoint(rectangle.x + rectangle.width, rectangle.y, rectangle.x + rectangle.width, rectangle.y + rectangle.height, x1, y1, x2, y2));</span>
		}
<span class="nc bnc" id="L115" title="All 2 branches missed.">		if(intersectLineSegment(rectangle.x, rectangle.y + rectangle.height, rectangle.x + rectangle.width, rectangle.y + rectangle.height, x1, y1, x2, y2)) {</span>
<span class="nc" id="L116">			return Optional.of(intersectionPoint(rectangle.x, rectangle.y + rectangle.height, rectangle.x + rectangle.width, rectangle.y + rectangle.height, x1, y1, x2, y2));</span>
		}

<span class="nc" id="L119">		return Optional.empty();</span>
	}

	public static VPoint intersectionPoint(@NotNull final VLine line1, @NotNull final VLine line2) {
<span class="nc" id="L123">		return intersectionPoint(line1.x1, line1.y1, line1.x2, line1.y2, line2.x1, line2.y1, line2.x2, line2.y2);</span>
	}

	/**
	 * Tests if there is a intersection between the {@link VRectangle} boundary and the line-segment defined by ((x1, y1), (x2, y2)).
	 *
	 * @param rectangle the rectangle
	 * @param x1        the x-coordinate of the first point of the line-segment
	 * @param y1        the y-coordinate of the first point of the line-segment
	 * @param x2        the x-coordinate of the second point of the line-segment
	 * @param y2        the y-coordinate of the second point of the line-segment
	 *
	 * @return true if there is an intersection, false otherwise.
	 */
	public static boolean intersectsRectangleBoundary(@NotNull final VRectangle rectangle, double x1, double y1, double x2, double y2) {
<span class="nc bnc" id="L138" title="All 2 branches missed.">		return  intersectLineSegment(rectangle.x, rectangle.y, rectangle.x + rectangle.width, rectangle.y, x1, y1, x2, y2) ||</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">				intersectLineSegment(rectangle.x, rectangle.y, rectangle.x, rectangle.y + rectangle.height, x1, y1, x2, y2) ||</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">				intersectLineSegment(rectangle.x + rectangle.width, rectangle.y, rectangle.x + rectangle.width, rectangle.y + rectangle.height, x1, y1, x2, y2) ||</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">				intersectLineSegment(rectangle.x, rectangle.y + rectangle.height, rectangle.x + rectangle.width, rectangle.y + rectangle.height, x1, y1, x2, y2);</span>
	}

	/**
	 * Computes the intersection of two lines (p1,p2) and (q1, q2).
	 * Algorithm from: /http://mathworld.wolfram.com/Line-LineIntersection.html
	 *
	 * Assumption: the lines (p1,p2) and (q1, q2) are not co-linear.
	 *
	 * @param x1 the x-coordinate of p1
	 * @param y1 the y-coordinate of p1
	 * @param x2 the x-coordinate of p2
	 * @param y2 the y-coordinate of p2
	 * @param x3 the x-coordinate of q1
	 * @param y3 the y-coordinate of q1
	 * @param x4 the x-coordinate of q2
	 * @param y4 the y-coordinate of q2
	 *
	 * @return the intersection of two lines (p1,p2) and (q1, q2).
	 */
	public static VPoint intersectionPoint(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {
<span class="fc" id="L162">		double a = det2D(x1, x2, y1, y2);</span>
<span class="fc" id="L163">		double b = det2D(x3, x4, y3, y4);</span>
<span class="fc" id="L164">		double c = det2D(x1-x2, x3 - x4, y1 - y2, y3 - y4);</span>

<span class="pc bpc" id="L166" title="2 of 4 branches missed.">		assert c != 0;</span>

<span class="fc" id="L168">		double x = det2D(a, b, x1 - x2, x3 - x4) / c;</span>
<span class="fc" id="L169">		double y = det2D(a, b, y1 - y2, y3 - y4) / c;</span>

<span class="fc" id="L171">		return new VPoint(x,y);</span>
	}

	/**
	 * Computes the centroid of a poylgon defined by a list of points.
	 *
	 * Assumption: the list [p1, ..., pn] is sorted and for a valid simple polygon and pi != pj
	 * for all points in the list.
	 *
	 * @param polygon a list of points defining the polygon.
	 *
	 * @return the centroid of the polygon
	 */
	public static VPoint getPolygonCentroid(@NotNull final List&lt;? extends IPoint&gt; polygon){
<span class="fc" id="L185">        double area = signedAreaOfPolygon(polygon);</span>
<span class="fc" id="L186">        double xValue = 0;</span>
<span class="fc" id="L187">        double yValue = 0;</span>

<span class="pc bpc" id="L189" title="2 of 4 branches missed.">        assert polygon.size() &gt; 2;</span>

<span class="fc" id="L191">        int j = 0;</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        for (int i = 0; i &lt; polygon.size(); i++) {</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        	if(i &lt; polygon.size() - 1) {</span>
<span class="fc" id="L194">        		j = i + 1;</span>
	        }
	        else {
<span class="fc" id="L197">        		j = 0;</span>
	        }

<span class="fc" id="L200">            xValue += (polygon.get(i).getX() + polygon.get(j).getX())</span>
<span class="fc" id="L201">                    * (polygon.get(i).getX() * polygon.get(j).getY()</span>
<span class="fc" id="L202">                    - polygon.get(i).getY() * polygon.get(j).getX());</span>
<span class="fc" id="L203">            yValue += (polygon.get(i).getY() + polygon.get(j).getY())</span>
<span class="fc" id="L204">                    * (polygon.get(i).getX() * polygon.get(j).getY()</span>
<span class="fc" id="L205">                    - polygon.get(i).getY() * polygon.get(j).getX());</span>
        }
<span class="fc" id="L207">        xValue /= (6 * area);</span>
<span class="fc" id="L208">        yValue /= (6 * area);</span>

<span class="pc bpc" id="L210" title="4 of 8 branches missed.">        if(xValue == Double.NaN || yValue == Double.NaN || area == 0 || area == Double.NaN) {</span>
<span class="nc" id="L211">        	throw new IllegalArgumentException(&quot;invalid point list&quot;);</span>
        }

<span class="fc" id="L214">        return new VPoint(xValue, yValue);</span>
    }

	/**
	 * Computes the circumcenter of a triangle defined by (p1, p2, p3).
	 *
	 * Assumption: p1 != p2 != p3 != p1.
	 *
	 * @param p1 the first point of the triangle
	 * @param p2 the second point of the triangle
	 * @param p3 the third point of the triangle
	 *
	 * @return the circumcenter of a triangle
	 */
	public static VPoint getCircumcenter(@NotNull final IPoint p1, @NotNull final IPoint p2, @NotNull final IPoint p3) {
<span class="pc bpc" id="L229" title="4 of 8 branches missed.">		assert !p1.equals(p2) &amp;&amp; !p1.equals(p3) &amp;&amp; !p2.equals(p3);</span>
<span class="fc" id="L230">		return getCircumcenter(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());</span>
	}

	public static VPoint getCircumcenter(final double x1, final double y1, final double x2, final double y2, final double x3, final double y3) {
<span class="fc" id="L234">		double d = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));</span>
<span class="fc" id="L235">		double x = ((x1 * x1 + y1 * y1) * (y2 - y3)</span>
				+ (x2 * x2 + y2 * y2) * (y3 - y1)
				+ (x3 * x3 + y3 * y3) * (y1 - y2)) / d;
<span class="fc" id="L238">		double y = ((x1 * x1 + y1 * y1) * (x3 - x2)</span>
				+ (x2 * x2 + y2 * y2) * (x1 - x3)
				+ (x3 * x3 + y3 * y3) * (x2 - x1)) / d;

<span class="fc" id="L242">		return new VPoint(x,y);</span>
	}

	/**
	 * Tests if the {@link IPoint} q lies inside the circumcenter of the triangle (p1, p2, p3) by
	 * computing the circumcenter.
	 *
	 * @param p1 the first point of the triangle
	 * @param p2 the second point of the triangle
	 * @param p3 the third point of the triangle
	 * @param q  the point which might lie inside the circumcenter
	 *
	 * @return true if q lies inside the circumcenter, false otherwise
	 */
	public static boolean isInCircumscribedCycle(@NotNull final IPoint p1, @NotNull final IPoint p2, @NotNull final IPoint p3, @NotNull final IPoint q) {
<span class="nc" id="L257">		VPoint circumcenter = getCircumcenter(p1, p2, p3);</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">		return circumcenter.distance(q) &lt; circumcenter.distance(p1);</span>
	}

	public static VPoint getTriangleMidpoint(final double x1, final double y1, final double x2, final double y2, final double x3, final double y3) {
<span class="fc" id="L262">		return new VPoint((x1 + x2 + x3) / 3.0,</span>
				(y1 + y2 + y3) / 3.0);
	}

	public static List&lt;VPoint&gt; getDiscDiscretizationPoints(
			@NotNull final VCircle circle,
			final int numberOfCircles,
			final int numberOfPointsOfLargestCircle,
			final double anchorAngle,
			final double angle) {
<span class="nc" id="L272">		return getDiscDiscretizationPoints(null, false, circle, numberOfCircles, numberOfPointsOfLargestCircle, anchorAngle, angle);</span>
	}

	public static List&lt;VPoint&gt; getDiscDiscretizationGridPoints(@Nullable final VCircle circle, double edgeLen) {
<span class="nc" id="L276">		int n = (int)(circle.getRadius() * 2 / edgeLen) + 1;</span>
<span class="nc" id="L277">		List&lt;VPoint&gt; points = new ArrayList&lt;&gt;(n * n);</span>
<span class="nc" id="L278">		double x = circle.getCenter().x - circle.getRadius();</span>
<span class="nc" id="L279">		double y = circle.getCenter().y - circle.getRadius();</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">		for (int i = 0; i &lt; n; i++) {</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">			for(int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L282">				VPoint point = new VPoint(x+i * edgeLen, y+j * edgeLen);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">				if(circle.contains(point)) {</span>
<span class="nc" id="L284">					points.add(point);</span>
				}
			}
		}
<span class="nc" id="L288">		return points;</span>
	}

	/**
	 * Generates a set of points which are positioned inside a disc segment. The points are placed equidistant on one or multiple circles
	 * with the center at the center of the disc and the radius smaller or equals the radius of the disc.
	 *
	 * @param random                            a random number generator which will only be used if varyDirection is true.
	 * @param varyDirection                     if true the generated points will be rotated by a random offset
	 * @param circle                            the circle defining the disc (containing the points)
	 * @param numberOfCircles                   the number of circles
	 * @param numberOfPointsOfLargestCircle     the number of points of the most outer circle
	 * @param anchorAngle                       start angle3D of the segment
	 * @param angle                             anchorAngle + angle3D = end angle3D of the segment
	 *
	 * @return a set of points which are positioned inside a disc segment
	 */
	public static List&lt;VPoint&gt; getDiscDiscretizationPoints(
			@Nullable final Random random,
			final boolean varyDirection,
			@NotNull final VCircle circle,
			final int numberOfCircles,
			final int numberOfPointsOfLargestCircle,
			final double anchorAngle,
			final double angle) {

<span class="nc bnc" id="L314" title="All 6 branches missed.">		assert random != null || !varyDirection;</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">		double randOffset = varyDirection ? random.nextDouble() : 0;</span>

<span class="nc" id="L317">		List&lt;VPoint&gt; reachablePositions = new ArrayList&lt;&gt;();</span>

		// iterate through all circles
<span class="nc bnc" id="L320" title="All 2 branches missed.">		for (int j = 1; j &lt;= numberOfCircles; j++) {</span>

<span class="nc" id="L322">			double circleOfGrid = circle.getRadius() * j / numberOfCircles;</span>

<span class="nc" id="L324">			int numberOfGridPoints = (int) Math.ceil(circleOfGrid / circle.getRadius() * numberOfPointsOfLargestCircle);</span>

			// reduce number of grid points proportional to the constraint of direction
<span class="nc bnc" id="L327" title="All 2 branches missed.">			if (angle &lt; 2.0 * Math.PI) {</span>
<span class="nc" id="L328">				numberOfGridPoints = (int) Math.ceil(numberOfGridPoints * angle / (2.0 * Math.PI));</span>
			}

<span class="nc" id="L331">			double angleDelta = angle / numberOfGridPoints;</span>

			// iterate through all angles and compute absolute positions of grid points
<span class="nc bnc" id="L334" title="All 2 branches missed.">			for (int i = 0; i &lt; numberOfGridPoints; i++) {</span>

<span class="nc" id="L336">				double x = circleOfGrid * Math.cos(anchorAngle + angleDelta * (randOffset + i)) + circle.getCenter().getX();</span>
<span class="nc" id="L337">				double y = circleOfGrid * Math.sin(anchorAngle + angleDelta * (randOffset + i)) + circle.getCenter().getY();</span>
<span class="nc" id="L338">				reachablePositions.add(new VPoint(x, y));</span>
			}
		}

<span class="nc" id="L342">		return reachablePositions;</span>
	}


	/**
	 * Computes the point on the line segment that is closest to the given point.
	 * Algorithm from: http://stackoverflow.com/questions/3120357/get-closest-point-to-a-line
	 *
	 * @param point the point to which the counterpart should be computed
	 * @param line line representing the segment
	 *
	 * @return the point on the line that is closest to p
	 */
	public static VPoint closestToSegment(@NotNull final VLine line, @NotNull final IPoint point) {
<span class="fc" id="L356">		VPoint a2p = new VPoint(point.getX() - line.x1, point.getY() - line.y1);</span>
<span class="fc" id="L357">		VPoint a2b = new VPoint(line.x2 - line.x1, line.y2 - line.y1);</span>

		// the line is not a line or a very short line
<span class="fc bfc" id="L360" title="All 4 branches covered.">		if(Math.abs(a2b.x) &lt; GeometryUtils.DOUBLE_EPS &amp;&amp; Math.abs(a2b.y) &lt; GeometryUtils.DOUBLE_EPS) {</span>
<span class="fc" id="L361">			return new VPoint(line.x1, line.y1);</span>
		}

		// the point is very close or equal to one of the points of the line
<span class="fc bfc" id="L365" title="All 4 branches covered.">		if(Math.abs(a2p.x) &lt; GeometryUtils.DOUBLE_EPS &amp;&amp; Math.abs(a2p.y) &lt; GeometryUtils.DOUBLE_EPS) {</span>
<span class="fc" id="L366">			return new VPoint(point.getX(), point.getY());</span>
		}

<span class="fc" id="L369">		double distAB = a2b.x * a2b.x + a2b.y * a2b.y;</span>
<span class="fc" id="L370">		double a2p_dot_a2b = a2p.x * a2b.x + a2p.y * a2b.y;</span>

		// normalize t to [0,1] to stay on the line segment
<span class="fc" id="L373">		double t = Math.min(1, Math.max(0, a2p_dot_a2b / distAB));</span>
<span class="fc" id="L374">		return new VPoint(line.x1 + a2b.x * t, line.y1 + a2b.y * t);</span>
	}


	/**
	 * Computes the area (it maybe a negative area) of the parallelogram defined by p, q, r.
	 * The area is zero if and only if p, q, r are co-linear.
	 *
	 * @param pX x-coordinate of p
	 * @param pY y-coordinate of p
	 * @param qX x-coordinate of q
	 * @param qY y-coordinate of q
	 * @param rX x-coordinate of r
	 * @param rY y-coordinate of r
	 *
	 * @return area or negative area of the parallelogram defined by p, q, r
	 */
	public static double ccw(final double qX, final double qY, final double pX, final double pY, final double rX, final double rY) {
<span class="fc" id="L392">		return -((qX - pX) * (rY - pY) - (rX - pX) * (qY - pY));</span>
	}

	/**
	 * Computes the area (it maybe a negative area) of the parallelogram defined by p, q, r.
	 * The area is zero if and only if p, q, r are co-linear.
	 *
	 * @param pX x-coordinate of p
	 * @param pY y-coordinate of p
	 * @param qX x-coordinate of q
	 * @param qY y-coordinate of q
	 * @param rX x-coordinate of r
	 * @param rY y-coordinate of r
	 *
	 * @return area or negative area of the parallelogram defined by p, q, r
	 */
	public static double ccwRobust(final double qX, final double qY, final double pX, final double pY, final double rX, final double rY) {
<span class="fc" id="L409">		double result = -((qX - pX) * (rY - pY) - (rX - pX) * (qY - pY));</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">		if(Math.abs(result) &lt;= DOUBLE_EPS) {</span>
<span class="fc" id="L411">			return 0.0;</span>
		}
		else {
<span class="fc" id="L414">			return result;</span>
		}
	}

	/**
	 * Returns true if q = (xq, yq) is right of the oriented-line defined by (p1 = (x1, y1), p2 = (x2, y2)).
	 *
	 * @param x1 the x-coordinate of p1
	 * @param y1 the y-coordinate of p1
	 * @param x2 the x-coordinate of p2
	 * @param y2 the y-coordinate of p2
	 * @param xq the x-coordinate of q
	 * @param yq the y-coordinate of q
	 *
	 * @return true if q is right of the oriented-line defined by (p1, p2), false otherwise
	 */
	public static boolean isRightOf(final double x1, final double y1, final double x2, final double y2, final double xq, final double yq) {
<span class="nc" id="L431">		return isCW(x1, y1, x2, y2, xq, yq);</span>
	}

	/**
	 * Returns true if q is right of the oriented-line defined by (p1, p2).
	 * @param p1 the start point of the oriented line
	 * @param p2 the end point of the oriented line
	 * @param q  the point which will be tested with respect toe the oriented line
	 *
	 * @return true if q is right of the oriented-line defined by (p1, p2), false otherwise
	 */
	public static boolean isRightOf(@NotNull final IPoint p1, @NotNull final IPoint p2, @NotNull final IPoint q) {
<span class="fc" id="L443">		return isRightOf(p1, p2, q.getX(), q.getY());</span>
	}

	/**
	 * Returns true if q is left of the oriented-line defined by (p1, p2).
	 *
	 * @param p1 the start point of the oriented line
	 * @param p2 the end point of the oriented line
	 * @param q  the point which will be tested with respect toe the oriented line
	 *
	 * @return true if q is left of the oriented-line defined by (p1, p2), false otherwise
	 */
	public static boolean isLeftOf(@NotNull final IPoint p1, @NotNull final IPoint p2, @NotNull final IPoint q) {
<span class="nc" id="L456">		return isLeftOf(p1, p2, q.getX(), q.getY());</span>
	}

	/**
	 * Returns true if q = (x, y) is right of the oriented-line defined by (p1, p2).
	 * @param p1 the start point of the oriented-line
	 * @param p2 the end point of the oriented-line
	 * @param x  x-coordinate of q
	 * @param y  y-coordinate of q
	 *
	 * @return true if q is right of the oriented-line defined by (p1, p2), false otherwise
	 */
	public static boolean isRightOf(@NotNull final IPoint p1, @NotNull final IPoint p2, final double x, final double y) {
<span class="fc" id="L469">		return isCW(p1.getX(), p1.getY(), p2.getX(), p2.getY(), x, y);</span>
	}

	/**
	 * Returns true if q = (xq, yq) is left of the oriented-line defined by (p1 = (x1,y1), p2 = (x2,y2)).
	 * @param x1 x-coordinate of p1
	 * @param y1 y-coordinate of p1
	 * @param x2 x-coordinate of p2
	 * @param y2 y-coordinate of p2
	 * @param xq x-coordinate of q
	 * @param yq y-coordinate of q
	 *
	 * @return true if q is left of the oriented-line defined by (p1, p2), false otherwise
	 */
	public static boolean isLeftOf(final double x1, final double y1, final double x2, final double y2, final double xq, final double yq) {
<span class="nc" id="L484">		return isCCW(x1, y1, x2, y2, xq, yq);</span>
	}

	/**
	 * Returns true if q = (x, y) is left of the oriented-line defined by (p1, p2).
	 *
	 * @param p1 the start point of the oriented line
	 * @param p2 the end point of the oriented line
	 * @param x  x-coordinate of q
	 * @param y  y-coordinate of q
	 *
	 * @return true if q is left of the oriented-line defined by (p1, p2), false otherwise
	 */
	public static boolean isLeftOf(@NotNull final IPoint p1, @NotNull final IPoint p2, final double x, final double y) {
<span class="nc" id="L498">		return isCCW(p1.getX(), p1.getY(), p2.getX(), p2.getY(), x, y);</span>
	}

	/**
	 * Tests if the simple polygon is ccw oriented by testing if 3 points of the polygon are ccw oriented.
	 *
	 * Assumption: the polygon is a valid simple polygon.
	 *
	 * @param polygon a simple polygon
	 *
	 * @return true if the polygon is ccw oriented, false otherwise
	 */
	public static boolean isCCW(final @NotNull VPolygon polygon) {
<span class="nc" id="L511">		List&lt;VPoint&gt; points = polygon.getPath();</span>

<span class="nc bnc" id="L513" title="All 4 branches missed.">		assert points.size() &gt;= 3;</span>

		// find the most-left, most-bottom point of the polygon
<span class="nc" id="L516">		VPoint mostLeft = points.get(0);</span>
<span class="nc" id="L517">		int indexMostLeft = 0;</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">		for(int i = 1; i &lt; points.size(); i++) {</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">			if(mostLeft.getX() &gt; points.get(i).getX() ||</span>
<span class="nc bnc" id="L520" title="All 4 branches missed.">					(Double.compare(mostLeft.getX(), points.get(i).getX()) == 0 &amp;&amp; mostLeft.getY() &gt; points.get(i).getY())) {</span>
<span class="nc" id="L521">				mostLeft = points.get(i);</span>
<span class="nc" id="L522">				indexMostLeft = i;</span>
			}
		}

		// get the next point and the prev point
<span class="nc" id="L527">		VPoint next = points.get((indexMostLeft+1) % points.size());</span>
<span class="nc" id="L528">		VPoint prev = points.get((indexMostLeft + points.size() - 1) % points.size());</span>

<span class="nc" id="L530">		return isLeftOf(mostLeft, next, prev);</span>

	}

	/**
	 * Returns the angle3D between the x-axis, p1 and p2.
	 *
	 * @param p1 the first point
	 * @param p2 the second point
	 *
	 * @return the angle3D between the x-axis, p1 and p2
	 */
	public static double angleTo(@NotNull final VPoint p1, @NotNull final VPoint p2) {
<span class="fc" id="L543">		double atan2 = Math.atan2(p1.y - p2.y, p1.x - p2.x);</span>

<span class="fc bfc" id="L545" title="All 2 branches covered.">		if (atan2 &lt; 0.0) {</span>
<span class="fc" id="L546">			atan2 = Math.PI * 2 + atan2;</span>
		}

<span class="fc" id="L549">		return atan2;</span>
	}

	public static double angleTo(@NotNull final double p1x,  final double p1y, final double p2x, final double p2y) {
<span class="fc" id="L553">		double atan2 = Math.atan2(p1y - p2y, p1x - p2x);</span>

<span class="fc bfc" id="L555" title="All 2 branches covered.">		if (atan2 &lt; 0.0) {</span>
<span class="fc" id="L556">			atan2 = Math.PI * 2 + atan2;</span>
		}

<span class="fc" id="L559">		return atan2;</span>
	}

	/**
	 * Calculate the counter clockwise result for the three given points.
	 * &lt;ol&gt;
	 *     &lt;li&gt;ccw(p1,p2,p3) smaller than 0 if p3 is left of Line(p1,p2)&lt;/li&gt;
	 *     &lt;li&gt;ccw(p1,p2,p3) equals 0 if p3 lies on Line(p1,p2)&lt;/li&gt;
	 *     &lt;li&gt;ccw(p1,p2,p3) larger than 0 if p3 is right of Line(p1,p2)&lt;/li&gt;
	 * &lt;/ol&gt;
	 *
	 * @param p1 first point
	 * @param p2 second point
	 * @param p3 third point
	 *
	 * @return ccw(p1 p2 p3)
	 */
	public static double ccw(@NotNull final IPoint p1, @NotNull final IPoint p2, @NotNull final IPoint p3) {
<span class="fc" id="L577">		return ccwRobust(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());</span>
	}

	/**
	 * Tests if q -&gt; p -&gt; r are counter clockwise oriented.
	 *
	 * @param qX x-coordinate of q
	 * @param qY y-coordinate of q
	 * @param pX x-coordinate of p
	 * @param pY y-coordinate of p
	 * @param rX x-coordinate of r
	 * @param rY y-coordinate of r
	 *
	 * @return true if q -&gt; p -&gt; r are counter clockwise oriented, false otherwise
	 */
	public static boolean isCCW(final double qX, final double qY, final double pX, final double pY, final double rX, final double rY) {
<span class="fc bfc" id="L593" title="All 2 branches covered.">		return ccwRobust(qX, qY, pX, pY, rX, rY) &gt; 0;</span>
	}

	/**
	 * Tests if p1 -&gt; p2 -&gt; p3 are counter clockwise oriented.
	 *
	 * @param p1 the first point
	 * @param p2 the second point
	 * @param p3 the third point
	 *
	 * @return true if p1 -&gt; p2 -&gt; p3 are counter clockwise oriented, false otherwise
	 */
	public static boolean isCCW(final IPoint p1, final IPoint p2, final IPoint p3) {
<span class="fc" id="L606">		return isCCW(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());</span>
	}

	/**
	 * Tests if q -&gt; p -&gt; r are clockwise oriented.
	 *
	 * @param qX x-coordinate of q
	 * @param qY y-coordinate of q
	 * @param pX x-coordinate of p
	 * @param pY y-coordinate of p
	 * @param rX x-coordinate of r
	 * @param rY y-coordinate of r
	 *
	 * @return true if q -&gt; p -&gt; r are clockwise oriented, false otherwise
	 */
	public static boolean isCW(final double qX, final double qY, final double pX, final double pY, final double rX, final double rY) {
<span class="fc bfc" id="L622" title="All 2 branches covered.">		return ccwRobust(qX, qY, pX, pY, rX, rY) &lt; 0;</span>
	}

	/**
	 * Tests if p1 -&gt; p2 -&gt; p3 are clockwise oriented.
	 *
	 * @param p1 the first point
	 * @param p2 the second point
	 * @param p3 the third point
	 *
	 * @return true if p1 -&gt; p2 -&gt; p3 are clockwise oriented, false otherwise
	 */
	public static boolean isCW(final IPoint p1, final IPoint p2, final IPoint p3) {
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">		return ccw(p1, p2, p3) &lt; 0;</span>
	}

	/**
	 * Tests if the line-segment (p1, p2) intersects the line (p, q).
	 *
	 * @param p     point defining the line
	 * @param q     point defining the line
	 * @param p1    point defining the line-segment
	 * @param p2    point defining the line-segment
	 *
	 * @return true if the line-segment (p1, p2) intersects the line (p, q), otherwise false.
	 */
	public static boolean intersectLine(@NotNull final IPoint p, @NotNull final IPoint q, @NotNull final IPoint p1, @NotNull final IPoint p2) {
<span class="fc" id="L649">		double ccw1 = ccw(p, q, p1);</span>
<span class="fc" id="L650">		double ccw2 = ccw(p, q, p2);</span>
<span class="pc bpc" id="L651" title="1 of 8 branches missed.">		return (ccw1 &lt; 0 &amp;&amp; ccw2 &gt; 0) || (ccw1 &gt; 0 &amp;&amp; ccw2 &lt; 0);</span>
	}

	public static boolean intersectLine(@NotNull final VLine line, @NotNull final IPoint p1, @NotNull final IPoint p2) {
<span class="nc" id="L655">		double ccw1 = ccw(new VPoint(line.getP1()), new VPoint(line.getP2()), p1);</span>
<span class="nc" id="L656">		double ccw2 = ccw(new VPoint(line.getP1()), new VPoint(line.getP2()), p2);</span>
<span class="nc bnc" id="L657" title="All 8 branches missed.">		return (ccw1 &lt; 0 &amp;&amp; ccw2 &gt; 0) || (ccw1 &gt; 0 &amp;&amp; ccw2 &lt; 0);</span>
	}

	/**
	 * Tests if the line-segment (p1, p2) intersects the line (p, q).
	 *
	 * @param pX    x-coordinate of p
	 * @param pY    y-coordinate of p
	 * @param qX    x-coordinate of q
	 * @param qY    y-coordinate of q
	 * @param p1X   x-coordinate of p1
	 * @param p1Y   y-coordinate of p1
	 * @param p2X   x-coordinate of p2
	 * @param p2Y   y-coordinate of p2
	 *
	 * @return true if the line-segment (p1, p2) intersects the line (p, q), otherwise false.
	 */
	public static boolean intersectLine(final double pX, final double pY, final double qX, final double qY, final double p1X, final double p1Y, final double p2X, final double p2Y) {
<span class="nc" id="L675">		double ccw1 = ccw(pX, pY, qX, qY, p1X, p1Y);</span>
<span class="nc" id="L676">		double ccw2 = ccw(pX, pY, qX, qY, p2X, p2Y);</span>
<span class="nc bnc" id="L677" title="All 8 branches missed.">		return (ccw1 &lt; 0 &amp;&amp; ccw2 &gt; 0) || (ccw1 &gt; 0 &amp;&amp; ccw2 &lt; 0);</span>
	}

	/**
	 * Tests if the line-segment (p1, p2) intersects the line (p, q).
	 * The &lt;tt&gt;eps&lt;/tt&gt; is used to define intersection in case of p1 or p2
	 * being very close to the line to avoid numerical errors.
	 *
	 * @param pX    x-coordinate of p
	 * @param pY    y-coordinate of p
	 * @param qX    x-coordinate of q
	 * @param qY    y-coordinate of q
	 * @param p1X   x-coordinate of p1
	 * @param p1Y   y-coordinate of p1
	 * @param p2X   x-coordinate of p2
	 * @param p2Y   y-coordinate of p2
	 * @param eps   a small distance by which a point close to a line will be regarded as to be on the line
	 *
	 * @return true if the line-segment (p1, p2) intersects the line (p, q), otherwise false.
	 */
	public static boolean intersectLine(final double pX, final double pY, final double qX, final double qY, final double p1X, final double p1Y, final double p2X, final double p2Y, final double eps) {
<span class="nc" id="L698">		double ccw1 = ccw(pX, pY, qX, qY, p1X, p1Y);</span>
<span class="nc" id="L699">		double ccw2 = ccw(pX, pY, qX, qY, p2X, p2Y);</span>
<span class="nc bnc" id="L700" title="All 8 branches missed.">		return (ccw1+eps &lt; 0 &amp;&amp; ccw2-eps &gt; 0) || (ccw1-eps &gt; 0 &amp;&amp; ccw2+eps &lt; 0);</span>
	}

	/**
	 * Computes the incenter of a triangle (p1, p2, p3).
	 *
	 * Assumption: the three points form a valid triangle.
	 *
	 * @param p1 the first point of the triangle
	 * @param p2 the second point of the triangle
	 * @param p3 the third point of the triangle
	 *
	 * @return the incenter of a triangle (p1, p2, p3)
	 */
	public static VPoint getIncenter(@NotNull final IPoint p1, @NotNull final IPoint p2, @NotNull final IPoint p3) {
<span class="fc" id="L715">		double a = p1.distance(p2);</span>
<span class="fc" id="L716">		double b = p2.distance(p3);</span>
<span class="fc" id="L717">		double c = p3.distance(p1);</span>
<span class="fc" id="L718">		double perimeter = a + b + c;</span>

<span class="fc" id="L720">		VPoint incenter = new VPoint((a * p3.getX() + b * p1.getX() + c * p2.getX()) / perimeter,</span>
<span class="fc" id="L721">				(a * p3.getY() + b * p1.getY() + c * p2.getY()) / perimeter);</span>

<span class="fc" id="L723">		return incenter;</span>
	}

	/**
	 * Computes the incenter circle radius of a triangle (p1, p2, p3).
	 *
	 * Assumption: the three points form a valid triangle.
	 *
	 * @param p1 the first point of the triangle
	 * @param p2 the second point of the triangle
	 * @param p3 the third point of the triangle
	 *
	 * @return the incenter circle radius of a triangle (p1, p2, p3)
	 */
	public static double getIncircleRaduis(@NotNull final IPoint p1, @NotNull final IPoint p2, @NotNull final IPoint p3) {
<span class="nc" id="L738">		double a = p1.distance(p2);</span>
<span class="nc" id="L739">		double b = p2.distance(p3);</span>
<span class="nc" id="L740">		double c = p3.distance(p1);</span>
<span class="nc" id="L741">		double perimeter = a + b + c;</span>
<span class="nc" id="L742">		double s = perimeter / 2.0;</span>

<span class="nc" id="L744">		return Math.sqrt(s * (s-a) * (s-b) * (s-c)) / s;</span>
	}

	public static double qualityInCircleOutCircle(@NotNull final IPoint p1, @NotNull final IPoint p2, @NotNull final IPoint p3) {
<span class="nc" id="L748">		double a = p1.distance(p2);</span>
<span class="nc" id="L749">		double b = p1.distance(p3);</span>
<span class="nc" id="L750">		double c = p3.distance(p2);</span>
		double part;
<span class="nc bnc" id="L752" title="All 6 branches missed.">		if(a != 0.0 &amp;&amp; b != 0.0 &amp;&amp; c != 0.0) {</span>
<span class="nc" id="L753">			part = ((b + c - a) * (c + a - b) * (a + b - c)) / (a * b * c);</span>
		}
		else {
<span class="nc" id="L756">			throw new IllegalArgumentException(new VTriangle(new VPoint(p1), new VPoint(p2), new VPoint(p3)).toString() + &quot; is not a feasible triangle!&quot;);</span>
		}
<span class="nc" id="L758">		return part;</span>
	}

	public static double qualityLongestEdgeInCircle(@NotNull final IPoint p1, @NotNull final IPoint p2, @NotNull final IPoint p3) {
<span class="nc" id="L762">		VTriangle tri = new VTriangle(new VPoint(p1), new VPoint(p2), new VPoint(p3));</span>
<span class="nc" id="L763">		double longestEdge = 0.0;</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">		for(VLine line : tri.getLines()) {</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">			if(longestEdge &lt; line.length()) {</span>
<span class="nc" id="L766">				longestEdge = line.length();</span>
			}
		}
<span class="nc bnc" id="L769" title="All 4 branches missed.">		assert longestEdge != 0.0;</span>
<span class="nc" id="L770">		return 2 * Math.sqrt(3) * tri.getIncircleRadius() / longestEdge;</span>
	}

	/**
	 * Tests if the half-line-segment starting at p in the direction (q-p) intersects the line-segment (p1,p2).
	 *
	 * @param p     the starting point of the half-line-segment
	 * @param q     the point defining the direction (q-p) of the half-line-segment
	 * @param p1    point defining the line-segment
	 * @param p2    point defining the line-segment
	 *
	 * @return true if the line-segment intersects the  half-line-segment defined, otherwise false.
	 */
	public static boolean intersectHalfLineSegment(@NotNull final IPoint p, @NotNull final IPoint q, @NotNull final IPoint p1, @NotNull final IPoint p2) {
<span class="fc" id="L784">		return intersectHalfLineSegment(p.getX(), p.getY(), q.getX(), q.getY(), p1.getX(), p1.getY(), p2.getX(), p2.getY());</span>
	}

	/*public static boolean intersectHalfLineSegment(final double pX, final double pY, final double qX, final double qY, final double p1X, final double p1Y, final double p2X, final double p2Y) {
		GeometryUtils.distanceToLineSegment()
	}*/

	/**
	 * Tests if the half-line-segment starting at p in the direction (q-p) intersects the line-segment (p1,p2).
	 *
	 * @param pX    x-coordinate of p
	 * @param pY    y-coordinate of p
	 * @param qX    x-coordinate of q
	 * @param qY    y-coordinate of q
	 * @param p1X   x-coordinate of p1
	 * @param p1Y   y-coordinate of p1
	 * @param p2X   x-coordinate of p2
	 * @param p2Y   y-coordinate of p2
	 *
	 * @return true if the line-segment intersects the  half-line-segment defined, otherwise false.
	 */
	public static boolean intersectHalfLineSegment(final double pX, final double pY, final double qX, final double qY, final double p1X, final double p1Y, final double p2X, final double p2Y) {
<span class="fc" id="L806">		double ccw1 = ccw(pX, pY, qX, qY, p1X, p1Y);</span>
<span class="fc" id="L807">		double ccw2 = ccw(pX, pY, qX, qY, p2X, p2Y);</span>

		// p1 and p2 are on different sides of directed line (q,p) if this is not the case there is no intersection
<span class="pc bpc" id="L810" title="5 of 8 branches missed.">		if((ccw1 &lt; 0 &amp;&amp; ccw2 &gt; 0) || (ccw1 &gt; 0 &amp;&amp; ccw2 &lt; 0)) {</span>

<span class="fc" id="L812">			double ccwq = ccw(p1X, p1Y, p2X, p2Y, qX, qY);</span>
<span class="fc" id="L813">			double ccwp = ccw(p1X, p1Y, p2X, p2Y, pX, pY);</span>

			// p and q on different sides, therefore the half-segment (q,p) intersects with the line (p1,p2)
<span class="pc bpc" id="L816" title="4 of 8 branches missed.">			if((ccwq &lt; 0 &amp;&amp; ccwp &gt; 0) || (ccwq &gt; 0 &amp;&amp; ccwp &lt; 0)) {</span>
<span class="fc" id="L817">				return true;</span>
			} // otherwise p has to be closer to the line-segment p1, p2 than q
			else {
<span class="pc bpc" id="L820" title="1 of 2 branches missed.">				return GeometryUtils.distanceToLineSegment(p1X, p1Y, p2X, p2Y, qX, qY) &lt; GeometryUtils.distanceToLineSegment(p1X, p1Y, p2X, p2Y, pX, pY);</span>
			}
		}
		else {
<span class="nc" id="L824">			return false;</span>
		}
	}

	/**
	 * Tests if the first line-segment (p,q) intersects the second line-segment (p1,p2).
	 *
	 * @param p     point defining the first line-segment
	 * @param q     point defining the first line-segment
	 * @param p1    point defining the second line-segment
	 * @param p2    point defining the second line-segment
	 *
	 * @return true if the first line-segment intersects the second line-segment, otherwise false.
	 */
	public static boolean intersectLineSegment(@NotNull final IPoint p, @NotNull final IPoint q, @NotNull final IPoint p1, @NotNull final IPoint p2) {
<span class="pc bpc" id="L839" title="1 of 4 branches missed.">		return intersectLine(p, q, p1, p2) &amp;&amp; intersectLine(p1, p2, p, q);</span>
	}

	public static boolean intersectLineSegment(@NotNull VLine line, @NotNull final IPoint p1, @NotNull final IPoint p2) {
<span class="nc bnc" id="L843" title="All 4 branches missed.">		return intersectLine(new VPoint(line.getP1()), new VPoint(line.getP2()), p1, p2) &amp;&amp; intersectLine(p1, p2, new VPoint(line.getP1()), new VPoint(line.getP2()));</span>
	}

	/**
	 * Tests if the first line-segment (p,q) intersects the second line-segment (p1,p2).
	 *
	 * @param p     point defining the first line-segment
	 * @param q     point defining the first line-segment
	 * @param p1    point defining the second line-segment
	 * @param p2    point defining the second line-segment
	 *
	 * @return true if the first line-segment intersects the second line-segment, otherwise false.
	 */
	public static boolean intersectLineSegment(@NotNull final Point2D.Double p, @NotNull final Point2D.Double q, @NotNull final Point2D.Double p1, @NotNull final Point2D.Double p2) {
<span class="nc bnc" id="L857" title="All 4 branches missed.">		return intersectLine(p.x, p.y, q.x, q.y, p1.x, p1.y, p2.x, p2.y) &amp;&amp; intersectLine(p1.x, p1.y, p2.x, p2.y, p.x, p.y, q.x, q.y);</span>
	}

	/**
	 * Tests if the first line-segment (p = (x1, y1), q = (x2, y2)) intersects the second line-segment (p1 = (x3, y3), p2 = (x4, y4)).
	 *
	 * @param x1 x-coordinate of p
	 * @param y1 y-coordinate of p
	 * @param x2 x-coordinate of q
	 * @param y2 y-coordinate of q
	 * @param x3 x-coordinate of p1
	 * @param y3 y-coordinate of p1
	 * @param x4 x-coordinate of p2
	 * @param y4 y-coordinate of p2
	 *
	 * @return true if the first line-segment intersects the second line-segment, otherwise false.
	 */
	public static boolean intersectLineSegment(final double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {
<span class="nc bnc" id="L875" title="All 4 branches missed.">		return intersectLine(x1, y1, x2, y2, x3, y3, x4, y4) &amp;&amp; intersectLine(x3, y3, x4, y4, x1, y1, x2, y2);</span>
	}

	/**
	 * Tests if the first line-segment (p = (x1, y1), q = (x2, y2)) intersects the second line-segment (p1 = (x3, y3), p2 = (x4, y4)).
	 *
	 * @param x1 x-coordinate of p
	 * @param y1 y-coordinate of p
	 * @param x2 x-coordinate of q
	 * @param y2 y-coordinate of q
	 * @param x3 x-coordinate of p1
	 * @param y3 y-coordinate of p1
	 * @param x4 x-coordinate of p2
	 * @param y4 y-coordinate of p2
	 *
	 * @return true if the first line-segment intersects the second line-segment, otherwise false.
	 */
	public static boolean isColinear(final double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {
<span class="nc bnc" id="L893" title="All 4 branches missed.">		return intersectLine(x1, y1, x2, y2, x3, y3, x4, y4) &amp;&amp; intersectLine(x3, y3, x4, y4, x1, y1, x2, y2);</span>
	}

	/**
	 * Tests if the first line-segment (p = (x1, y1), q = (x2, y2)) intersects the second line-segment (p1 = (x3, y3), p2 = (x4, y4)).
	 * The &lt;tt&gt;eps&lt;/tt&gt; is used to define intersection in case of p1 or p2
	 * being very close to the line to avoid numerical errors.
	 *
	 * @param x1 x-coordinate of p
	 * @param y1 y-coordinate of p
	 * @param x2 x-coordinate of q
	 * @param y2 y-coordinate of q
	 * @param x3 x-coordinate of p1
	 * @param y3 y-coordinate of p1
	 * @param x4 x-coordinate of p2
	 * @param y4 y-coordinate of p2
	 * @param eps a small distance by which a point close to a line will be regarded as to be on the line
	 *
	 * @return
	 */
	public static boolean intersectLineSegment(final double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4, double eps) {
<span class="nc bnc" id="L914" title="All 4 branches missed.">		return intersectLine(x1, y1, x2, y2, x3, y3, x4, y4, eps) &amp;&amp; intersectLine(x3, y3, x4, y4, x1, y1, x2, y2, eps);</span>
	}


	/**
	 * Tests if the triangle (p1,p2,p3) contains the point r.
	 *
	 * @param p1    point of the triangle
	 * @param p2    point of the triangle
	 * @param p3    point of the triangle
	 * @param r     point which the triangle might contain.
	 *
	 * @return true if the triangle (p1,p2,p3) contains the point r, otherwise false.
	 */
	public static boolean triangleContains(@NotNull final IPoint p1, @NotNull final IPoint p2, @NotNull final IPoint p3, @NotNull final IPoint r) {
		boolean b1, b2, b3;
<span class="fc" id="L930">		double d1 = GeometryUtils.ccw(r, p1, p2);</span>
<span class="fc" id="L931">		double d2 = GeometryUtils.ccw(r, p2, p3);</span>
<span class="fc" id="L932">		double d3 = GeometryUtils.ccw(r, p3, p1);</span>
<span class="pc bpc" id="L933" title="1 of 2 branches missed.">		b1 = d1 &lt; 0.0;</span>
<span class="fc bfc" id="L934" title="All 2 branches covered.">		b2 = d2 &lt; 0.0;</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">		b3 = d3 &lt; 0.0;</span>
<span class="fc bfc" id="L936" title="All 4 branches covered.">		return ((b1 == b2) &amp;&amp; (b2 == b3));</span>
	}

	/**
	 * &lt;p&gt;Tests if the circle defined by three non-lin points (p1,p2,p3) contains the point p.
	 * The center of the circle is the circumcenter of the triangle and the radius is equalt to the
	 * distance between the circumcenter and any point of {p1, p2, p3}.&lt;/p&gt;
	 *
	 * &lt;p&gt;Assumption: a, b, c are in ccw-order!&lt;/p&gt;
	 *
	 * @param a    point of the triangle
	 * @param b    point of the triangle
	 * @param c    point of the triangle
	 * @param p    point which the circle might contain.
	 *
	 * @return true, if the circle defined by three non-lin points (p1,p2,p3) contains the point p, otherwise false
	 */
	public static boolean isInsideCircle(@NotNull final IPoint a, @NotNull final IPoint b, @NotNull final IPoint c, @NotNull final IPoint p) {
<span class="nc" id="L954">		return isInsideCircle(a, b, c, p.getX(), p.getY());</span>
	}

	public static boolean isInsideCircle(@NotNull final IPoint a, @NotNull final IPoint b, @NotNull final IPoint c, @NotNull final IPoint p, double eps) {
<span class="nc" id="L958">		return isInsideCircle(a, b, c, p.getX(), p.getY(), eps);</span>
	}

	/**
	 * Tests whether or not the point (x,y) lies inside the circumcenter of the triangle (a, b, c).
	 * The method is more stable than direct use of the circumcenter since we normalize beforehand.
	 *
	 * Assumption: (a,b,c) form a valid triangle
	 *
	 * @param a the first point of the triangle
	 * @param b the second point of the triangle
	 * @param c the third point of the triangle
	 * @param x x-coordinate of the point of interest
	 * @param y y-coordinate of the point of interest
	 *
	 * @return true if (x,y) lies inside the circumcenter of the triangle (a, b, c), false otherwise
	 */
	public static boolean isInsideCircle(@NotNull final IPoint a, @NotNull final IPoint b, @NotNull final IPoint c, double x , double y, double eps) {
<span class="nc" id="L976">		double adx = a.getX() - x;</span>
<span class="nc" id="L977">		double ady = a.getY() - y;</span>
<span class="nc" id="L978">		double bdx = b.getX() - x;</span>
<span class="nc" id="L979">		double bdy = b.getY() - y;</span>
<span class="nc" id="L980">		double cdx = c.getX() - x;</span>
<span class="nc" id="L981">		double cdy = c.getY() - y;</span>

<span class="nc" id="L983">		double abdet = adx * bdy - bdx * ady;</span>
<span class="nc" id="L984">		double bcdet = bdx * cdy - cdx * bdy;</span>
<span class="nc" id="L985">		double cadet = cdx * ady - adx * cdy;</span>
<span class="nc" id="L986">		double alift = adx * adx + ady * ady;</span>
<span class="nc" id="L987">		double blift = bdx * bdx + bdy * bdy;</span>
<span class="nc" id="L988">		double clift = cdx * cdx + cdy * cdy;</span>

<span class="nc" id="L990">		double disc = alift * bcdet + blift * cadet + clift * abdet;</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">		return disc &gt; eps;</span>
	}

	public static boolean isInsideCircle(@NotNull final IPoint a, @NotNull final IPoint b, @NotNull final IPoint c, double x , double y) {
<span class="nc" id="L995">		return isInsideCircle(a, b, c, x, y, 0.0);</span>
	}


	/**
	 * Computes the cross product of two vectors and store it in the cross
	 * vector. This is a c-like call.
	 *
	 * @param v1    the first vector
	 * @param v2    the second vector
	 * @param cross
	 */
	public static void cross(@NotNull final double[] v1, @NotNull double[] v2, @NotNull double[] cross) {
<span class="fc" id="L1008">		cross[0] = v1[1] * v2[2] - v1[2] * v2[1];</span>
<span class="fc" id="L1009">		cross[1] = v1[2] * v2[0] - v1[0] * v2[2];</span>
<span class="fc" id="L1010">		cross[2] = v1[0] * v2[1] - v1[1] * v2[0];</span>

<span class="fc" id="L1012">	}</span>

	public static double dot(@NotNull final double[] a, @NotNull double[] b) {
<span class="fc" id="L1015">		return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];</span>
	}

	public static double dot(@NotNull final IPoint a, @NotNull final IPoint b) {
<span class="nc" id="L1019">		return a.getX()*b.getY() + a.getY()*b.getY();</span>
	}

	public static double[] norm3D(@NotNull final double[] a, @NotNull double[] b, @NotNull double[] c) {
<span class="fc" id="L1023">		double[][] a1 = new double[3][3];</span>
<span class="fc" id="L1024">		a1[0][0] = 1; a1[0][1] = a[1]; a1[0][2] = a[2];</span>
<span class="fc" id="L1025">		a1[1][0] = 1; a1[1][1] = b[1]; a1[1][2] = b[2];</span>
<span class="fc" id="L1026">		a1[2][0] = 1; a1[2][1] = c[1]; a1[2][2] = c[2];</span>

<span class="fc" id="L1028">		double[][] a2 = new double[3][3];</span>
<span class="fc" id="L1029">		a2[0][0] = a[0]; a2[0][1] = 1; a2[0][2] = a[2];</span>
<span class="fc" id="L1030">		a2[1][0] = b[0]; a2[1][1] = 1; a2[1][2] = b[2];</span>
<span class="fc" id="L1031">		a2[2][0] = c[0]; a2[2][1] = 1; a2[2][2] = c[2];</span>

<span class="fc" id="L1033">		double[][] a3 = new double[3][3];</span>
<span class="fc" id="L1034">		a3[0][0] = a[0]; a3[0][1] = a[1]; a3[0][2] = 1;</span>
<span class="fc" id="L1035">		a3[1][0] = b[0]; a3[1][1] = b[1]; a3[1][2] = 1;</span>
<span class="fc" id="L1036">		a3[2][0] = c[0]; a3[2][1] = c[1]; a3[2][2] = 1;</span>

<span class="fc" id="L1038">		double x = det3D(a1);</span>
<span class="fc" id="L1039">		double y = det3D(a2);</span>
<span class="fc" id="L1040">		double z = det3D(a3);</span>

<span class="fc" id="L1042">		return new double[]{x, y, z};</span>
	}

	public static double[] unitNorm(@NotNull final double[] a, @NotNull double[] b, @NotNull double[] c) {
<span class="fc" id="L1046">		double[] norm = norm3D(a, b, c);</span>
<span class="fc" id="L1047">		double len = len(norm[0], norm[1], norm[2]);</span>
<span class="fc" id="L1048">		return new double[]{norm[0] / len, norm[1] / len, norm[2] / len};</span>
	}



	public static void norm3D(@NotNull final double[] v) {
<span class="nc" id="L1054">		double len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);</span>
<span class="nc bnc" id="L1055" title="All 4 branches missed.">		assert len &gt; 0;</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">		if(len &gt; 0) {</span>
<span class="nc" id="L1057">			v[0] = v[0] / len;</span>
<span class="nc" id="L1058">			v[1] = v[1] / len;</span>
<span class="nc" id="L1059">			v[2] = v[2] / len;</span>
		}
<span class="nc" id="L1061">	}</span>

	/**
	 * Transforms a list forming a valid simple polygon into a {@link VPolygon} object.
	 *
	 * Assumption: the list of points form a valid simple polygon
	 *
	 * @param points the list of points forming a valid simple polygon
	 *
	 * @return a {@link VPolygon} object of the list of points
	 */
	public static VPolygon polygonFromPoints2D(@NotNull final List&lt;? extends IPoint&gt; points) {
<span class="fc" id="L1073">		Path2D.Double result = new Path2D.Double();</span>
<span class="pc bpc" id="L1074" title="1 of 2 branches missed.">		if (points.isEmpty())</span>
<span class="nc" id="L1075">			return new VPolygon(result);</span>

<span class="fc" id="L1077">		IPoint last = points.get(points.size() - 1);</span>
<span class="fc" id="L1078">		result.moveTo(last.getX(), last.getY());</span>

<span class="fc bfc" id="L1080" title="All 2 branches covered.">		for (int i = 0; i &lt; points.size(); i++) {</span>
<span class="fc" id="L1081">			result.lineTo(points.get(i).getX(), points.get(i).getY());</span>
		}

<span class="fc" id="L1084">		return new VPolygon(result);</span>
	}

	public static VPolygon polygonFromArea(@NotNull final Area area){
<span class="nc" id="L1088">		VPolygon tmpPolygon = new VPolygon(area);</span>
<span class="nc" id="L1089">		return polygonFromPoints2D(tmpPolygon.getPoints());</span>
	}

	/**
	 * Constructs a new Polygon defined by the vertices. It is assumed that
	 * all vertices are distinct.
	 *
	 * @param vertices the defining distinct vertices.
	 *
	 * @return a new Polygon
	 */
	public static VPolygon polygonFromPoints2D(@NotNull final IPoint... vertices) {
<span class="fc" id="L1101">		Path2D.Double result = new Path2D.Double();</span>
<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">		if (vertices.length == 0)</span>
<span class="nc" id="L1103">			return new VPolygon(result);</span>

<span class="fc" id="L1105">		IPoint last = vertices[vertices.length - 1];</span>
<span class="fc" id="L1106">		result.moveTo(last.getX(), last.getY());</span>

<span class="fc bfc" id="L1108" title="All 2 branches covered.">		for (int i = 0; i &lt; vertices.length; i++) {</span>
<span class="fc" id="L1109">			result.lineTo(vertices[i].getX(), vertices[i].getY());</span>
		}

<span class="fc" id="L1112">		return new VPolygon(result);</span>
	}

	/**
	 * Computes the area of a Polygon.
	 *
	 * @param vertices distinct vertices defining the polygon.
	 *
	 * @return the area of a polygon
	 */
	public static double signedAreaOfPolygon(@NotNull final List&lt;? extends IPoint&gt; vertices) {
<span class="fc" id="L1123">		double result = 0;</span>
<span class="pc bpc" id="L1124" title="1 of 2 branches missed.">		if(vertices.size() &gt;= 3) {</span>
<span class="fc bfc" id="L1125" title="All 2 branches covered.">			for (int i = 0; i &lt; vertices.size() - 1; i++) {</span>
<span class="fc" id="L1126">				result += vertices.get(i).getX() * vertices.get(i + 1).getY() - vertices.get(i + 1).getX() * vertices.get(i).getY();</span>
			}
<span class="fc" id="L1128">			int n = vertices.size() - 1;</span>
<span class="fc" id="L1129">			result += vertices.get(n).getX() * vertices.get(0).getY() - vertices.get(0).getX() * vertices.get(n).getY();</span>
		}
<span class="fc" id="L1131">		return result / 2.0;</span>
	}

	public static double signedAreaOfPolygon(@NotNull final double x[], @NotNull final double y[]) {
<span class="nc bnc" id="L1135" title="All 4 branches missed.">		assert x.length == y.length;</span>
<span class="nc" id="L1136">		double result = 0;</span>
<span class="nc bnc" id="L1137" title="All 2 branches missed.">		if(x.length &gt;= 3) {</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">			for (int i = 0; i &lt; x.length - 1; i++) {</span>
<span class="nc" id="L1139">				result += x[i] * y[i + 1] - x[i + 1] * y[i];</span>
			}
<span class="nc" id="L1141">			int n = x.length - 1;</span>
<span class="nc" id="L1142">			result += x[n] * y[0] - x[0] * y[n];</span>
		}
<span class="nc" id="L1144">		return result / 2.0;</span>
	}

	public static double signedAreaOfPolygon(@NotNull final IPoint... vertices) {
<span class="nc" id="L1148">		double result = 0;</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">		if(vertices.length &gt;= 3) {</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">			for (int i = 0; i &lt; vertices.length - 1; i++) {</span>
<span class="nc" id="L1151">				result += vertices[i].getX() * vertices[i + 1].getY() - vertices[i + 1].getX() * vertices[i].getY();</span>
			}
<span class="nc" id="L1153">			int n = vertices.length - 1;</span>
<span class="nc" id="L1154">			result += vertices[n].getX() * vertices[0].getY() - vertices[0].getX() * vertices[n].getY();</span>
		}
<span class="nc" id="L1156">		return result / 2.0;</span>
	}

	public static double areaOfTriangle(@NotNull final double x1, double y1, double x2, double y2, double x3, double y3){
<span class="nc" id="L1160">		return Math.abs(x1 * (y2 - y3) - x2 * (y1 - y3) + x3 * (y1 - y2));</span>
	}


	public static double areaOfPolygon(@NotNull final double x[], @NotNull final double y[]){
<span class="nc" id="L1165">		return Math.abs(signedAreaOfPolygon(x, y));</span>
	}

	public static double areaOfPolygon(@NotNull final double x[], @NotNull final double y[], @NotNull final double z[]){
<span class="pc bpc" id="L1169" title="4 of 8 branches missed.">		assert x.length &gt;= 3 &amp;&amp; x.length == y.length &amp;&amp; x.length == z.length;</span>

<span class="fc" id="L1171">		double[] total = new double[]{0, 0, 0};</span>

<span class="fc bfc" id="L1173" title="All 2 branches covered.">		for(int i = 0; i &lt; x.length; i++) {</span>
<span class="fc" id="L1174">			double[] vi1 = new double[] {x[i], y[i], z[i]};</span>
			double[] vi2;

<span class="fc bfc" id="L1177" title="All 2 branches covered.">			if(i == x.length - 1) {</span>
<span class="fc" id="L1178">				vi2 = new double[] {x[0], y[0], z[0]};</span>
			} else {
<span class="fc" id="L1180">				vi2 = new double[] {x[i+1], y[i+1], z[i+1]};</span>
			}

<span class="fc" id="L1183">			double[] prod = new double[3];</span>
<span class="fc" id="L1184">			cross(vi1, vi2, prod);</span>
<span class="fc" id="L1185">			total[0] += prod[0];</span>
<span class="fc" id="L1186">			total[1] += prod[1];</span>
<span class="fc" id="L1187">			total[2] += prod[2];</span>
		}

<span class="fc" id="L1190">		double result = dot(total, unitNorm(new double[]{x[0], y[0], z[0]}, new double[]{x[1], y[1], z[1]}, new double[]{x[2], y[2], z[2]}));</span>
<span class="fc" id="L1191">		return Math.abs(result/2.0);</span>
	}

	public static double areaOfPolygon(@NotNull final List&lt;? extends IPoint&gt; vertices){
<span class="fc" id="L1195">		return Math.abs(signedAreaOfPolygon(vertices));</span>
	}

	public static double areaOfPolygon(@NotNull final IPoint... vertices){
<span class="nc" id="L1199">		return Math.abs(signedAreaOfPolygon(vertices));</span>
	}

	/**
	 * Computes the distance from the line-segment defined by (p1,p2) to the point p.
	 *
	 * @param p1    first point of the line-segment
	 * @param p2    second point of the line-segment
	 * @param p     the point
	 *
	 * @return the distance from the line-segment defined by (p1,p2) to the point p.
	 */
	public static double distanceToLineSegment(@NotNull final IPoint p1, @NotNull final IPoint p2, @NotNull final IPoint p) {
<span class="nc" id="L1212">		return distanceToLineSegment(p1, p2, p.getX(), p.getY());</span>
	}

	/**
	 * Computes the distance from the line-segment defined by (p1,p2) to the point p = (x,y).
	 *
	 * @param p1    first point of the line-segment
	 * @param p2    second point of the line-segment
	 * @param x     x-coordinate of the point p
	 * @param y     y-coordinate of the point p
	 *
	 * @return the distance from the line-segment defined by (p1,p2) to the point p.
	 */
	public static double distanceToLineSegment(@NotNull final IPoint p1, @NotNull final IPoint p2, final double x, final double y) {
<span class="fc" id="L1226">		return distanceToLineSegment(p1.getX(), p1.getY(), p2.getX(), p2.getY(), x, y);</span>
	}

	/**
	 * Computes the Euclidean distance between p = (px, py) and q = (qx, qy).
	 *
	 * @param px    x-coordinate of p
	 * @param py    y-coordinate of p
	 * @param qx    x-coordinate of q
	 * @param qy    y-coordinate of q
	 *
	 * @return the Euclidean distance between p = (px, py) and q = (qx, qy)
	 */
	public static double distance(final double px, final double py, final double qx, final double qy) {
<span class="fc" id="L1240">		return Math.sqrt((px - qx) * (px - qx) + (py - qy) * (py - qy));</span>
	}

	/**
	 * Computes the distance between the line-segment (p1, p2) and the point (x, y).
	 *
	 * @param p1X   x-coordinate of p1
	 * @param p1Y   y-coordinate of p1
	 * @param p2X   x-coordinate of p2
	 * @param p2Y   y-coordinate of p2
	 * @param x     x-coordinate of the point of interest
	 * @param y     y-coordinate of the point of interest
	 *
	 * @return the distance between the line-segment (p1, p2) and the point (x, y)
	 */
	public static double distanceToLineSegment(final double p1X, final double p1Y, final double p2X, final double p2Y, final double x, final double y) {
		// special cases
		/*if(p1X == p2X) {
			if((y &gt; p1Y &amp;&amp; p1Y &gt; p2Y) || (y &lt; p1Y &amp;&amp; p1Y &lt; p2Y)) {
				return distance(p1X, p1Y, x, y);
			}
			else if((y &gt; p2Y &amp;&amp; p2Y &gt; p1Y) || (y &lt; p2Y &amp;&amp; p2Y &lt; p1Y)) {
				return distance(p2X, p2Y, x, y);
			}
			else {
				return Math.abs(p1X - x);
			}
		}

		if(p1Y == p2Y) {

			if((x &gt; p1X &amp;&amp; p1X &gt; p2X) || (x &lt; p1X &amp;&amp; p1X &lt; p2X)) {
				return distance(p1X, p1Y, x, y);
			}
			else if((x &gt; p2X &amp;&amp; p2X &gt; p1X) || (x &lt; p2X &amp;&amp; p2X &lt; p1X)) {
				return distance(p2X, p2Y, x, y);
			}
			else {
				return Math.abs(p1Y - y);
			}
		}*/

<span class="fc" id="L1282">		double len2 = (p2X - p1X) * (p2X - p1X) + (p2Y - p1Y) * (p2Y - p1Y);</span>
<span class="fc" id="L1283">		double r = ((x - p1X) * (p2X - p1X) + (y - p1Y) * (p2Y - p1Y)) / len2;</span>

<span class="fc bfc" id="L1285" title="All 2 branches covered.">		if (r &lt;= 0.0)</span>
<span class="fc" id="L1286">			return GeometryUtils.distance(p1X, p1Y, x, y);</span>
<span class="fc bfc" id="L1287" title="All 2 branches covered.">		if (r &gt;= 1.0)</span>
<span class="fc" id="L1288">			return GeometryUtils.distance(p2X, p2Y, x, y);</span>

<span class="fc" id="L1290">		double s = ((p1Y - y) * (p2X - p1X) - (p1X - x) * (p2Y - p1Y)) / len2;</span>
<span class="fc" id="L1291">		return Math.abs(s) * Math.sqrt(len2);</span>
	}

	/**
	 * Computes the distance between the line defined by (p1, p2) and the point (x, y).
	 *
	 * @param p1    first point of the line
	 * @param p2    second point of the line
	 * @param x     x-coordinate of the point of interest
	 * @param y     y-coordinate of the point of interest
	 *
	 * @return the distance between the line defined by (p1, p2) and the point (x, y).
	 */
	public static double distanceToLine(@NotNull final IPoint p1, @NotNull final IPoint p2, final double x, final double y) {
<span class="fc" id="L1305">		return distanceToLine(p1.getX(), p1.getY(), p2.getX(), p2.getY(), x, y);</span>
	}

	/**
	 * Computes the distance between the line defined by (p1, p2) and the point (x, y).
	 *
	 * @param p1X   x-coordinate of p1
	 * @param p1Y   y-coordinate of p1
	 * @param p2X   x-coordinate of p2
	 * @param p2Y   y-coordinate of p2
	 * @param x     x-coordinate of the point of interest
	 * @param y     y-coordinate of the point of interest
	 *
	 * @return the distance between the line defined by (p1, p2) and the point (x, y)
	 */
	public static double distanceToLine(final double p1X, final double p1Y, final double p2X, final double p2Y, final double x, final double y) {
<span class="fc" id="L1321">		double a = p1Y - p2Y;</span>
<span class="fc" id="L1322">		double b = p2X - p1X;</span>
<span class="fc" id="L1323">		double c = p1X * p2Y - p2X * p1Y;</span>
<span class="pc bpc" id="L1324" title="1 of 4 branches missed.">		if(a == 0 &amp;&amp; b == 0) {</span>
<span class="nc" id="L1325">			return 0.0;</span>
		}
		else {
<span class="fc" id="L1328">			return Math.abs(a * x + b * y + c) / Math.sqrt(a * a + b * b);</span>
		}
	}

	/**
	 * Tests if the point p is on the line-segment (p1, p2) (or very very close).
	 *
	 * @param p1        the first point of the line-segment
	 * @param p2        the second point of the line-segment
	 * @param p         the point of interest
	 * @param tolerance if the point is closer than this tolerance it is assumed that it is on it
	 *
	 * @return if the point p is on the line-segment (p1, p2) (or very very close), false otherwise
	 */
	public static boolean isOnEdge(@NotNull final IPoint p1, @NotNull final IPoint p2, @NotNull final IPoint p, double tolerance) {
<span class="nc bnc" id="L1343" title="All 2 branches missed.">		return distanceToLineSegment(p1, p2, p) &lt; tolerance;</span>
	}

	/**
	 * Computes the intersection points of a line and a circle. The line is supposed to have infinity
	 * length and is defined by the two points of the VLine.
	 *
	 * @param line      the line
	 * @param circle    the circle
	 *
	 * @return  all intersection poins of the line with the circle i.e. 1, 2 or 0 results.
	 */
	public static VPoint[] intersection(@NotNull final VLine line, @NotNull final VCircle circle) {
<span class="fc" id="L1356">		double m = line.slope();</span>
<span class="fc" id="L1357">		double d = line.getY1() - m * line.getX1();</span>
<span class="fc" id="L1358">		double a = circle.getCenter().getX();</span>
<span class="fc" id="L1359">		double b = circle.getCenter().getY();</span>

<span class="fc" id="L1361">		double discreminant = circle.getRadius() * circle.getRadius() * (1 + m*m) - (b -m * a -d) * (b - m * a - d);</span>


<span class="fc bfc" id="L1364" title="All 2 branches covered.">		if(discreminant &lt; 0) {</span>
<span class="fc" id="L1365">			return new VPoint[0];</span>
		}
<span class="fc bfc" id="L1367" title="All 2 branches covered.">		else if(discreminant == 0){</span>
<span class="fc" id="L1368">			double x = (a + b * m - d * m) / (1 + m*m);</span>
<span class="fc" id="L1369">			double y = m * x + d;</span>
<span class="fc" id="L1370">			return  new VPoint[]{new VPoint(x, y)};</span>
		}
		else {
<span class="fc" id="L1373">			double x1 = (a + b * m - d * m + Math.sqrt(discreminant)) / (1 + m*m);</span>
<span class="fc" id="L1374">			double y1 = m * x1 + d;</span>

<span class="fc" id="L1376">			double x2 = (a + b * m - d * m - Math.sqrt(discreminant)) / (1 + m*m);</span>
<span class="fc" id="L1377">			double y2 = m * x2 + d;</span>

<span class="fc" id="L1379">			return new VPoint[]{ new VPoint(x1, y1), new VPoint(x2, y2)};</span>
		}
	}

	/**
	 * The (smallest possible) angle3D at C from the triangle ACB.
	 *
	 * @param A first point of the triangle
	 * @param C second point of the triangle
	 * @param B third point of the triangle
	 *
	 * @return the (smallest possible) angle3D at C from the triangle ACB.
	 */
	public static double angle(@NotNull final IPoint A, @NotNull final IPoint C, @NotNull final IPoint B) {
<span class="fc" id="L1393">		return angle(A.getX(), A.getY(), C.getX(), C.getY(), B.getX(), B.getY());</span>
	}
	public static double angle(final double xa, final double ya, final double xc, final double yc, final double xb, final double yb) {
<span class="fc" id="L1396">		double phi1 = angleTo(xa, ya, xc, yc);</span>
<span class="fc" id="L1397">		double phi2 = angleTo(xb, yb, xc, yc);</span>
<span class="fc" id="L1398">		double phi = Math.abs(phi1 - phi2);</span>
<span class="fc" id="L1399">		return Math.min(phi, 2 * Math.PI - phi);</span>
	}

	public static double angle3D(
			final double ax, final double ay, final double az,
			final double bx, final double by, final double bz) {

<span class="nc" id="L1406">		double dot = (ax * bx + ay * by + az * bz);</span>
<span class="nc" id="L1407">		double aLen = len(ax, ay, az);</span>
<span class="nc" id="L1408">		double bLen = len(bx, by, bz);</span>
<span class="nc" id="L1409">		double c = dot / (aLen * bLen);</span>

<span class="nc bnc" id="L1411" title="All 2 branches missed.">		if(Math.abs(c - 1.0) &lt; GeometryUtils.DOUBLE_EPS) {</span>
<span class="nc" id="L1412">			return 0;</span>
		}
<span class="nc" id="L1414">		return Math.acos(c);</span>
	}

	public static double angle2D(
			final double ax, final double ay,
			final double bx, final double by) {

<span class="nc" id="L1421">		double dot = (ax * bx + ay * by);</span>
<span class="nc" id="L1422">		double aLen = len(ax, ay);</span>
<span class="nc" id="L1423">		double bLen = len(bx, by);</span>
<span class="nc" id="L1424">		double c = dot / (aLen * bLen);</span>

<span class="nc bnc" id="L1426" title="All 2 branches missed.">		if(Math.abs(c - 1.0) &lt; GeometryUtils.DOUBLE_EPS) {</span>
<span class="nc" id="L1427">			return 0;</span>
		}
<span class="nc" id="L1429">		return Math.acos(c);</span>
	}

	public static double len(final double ax, final double ay, final double az) {
<span class="fc" id="L1433">		return Math.sqrt(ax * ax + ay * ay + az * az);</span>
	}

	public static double len(final double ax, final double ay) {
<span class="nc" id="L1437">		return Math.sqrt(ax * ax + ay * ay);</span>
	}

	/**
	 * Computes the angle3D between the positive x-axis and the point (to - from).
	 * Result is in interval (0,2*PI) according to standard math usage.
	 *
	 * @see &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;https://en.wikipedia.org/wiki/Atan2&lt;/a&gt;
	 * @param from the first point / vector
	 * @param to   the second point / vector
	 *
	 * @return the angle3D between the positive x-axis and the vector (from -&gt; to)
	 */
	public static double angleTo(@NotNull final IPoint from, @NotNull final IPoint to) {
<span class="fc" id="L1451">		double atan2 = Math.atan2(to.getY() - from.getY(), to.getX() - from.getX());</span>

<span class="fc bfc" id="L1453" title="All 2 branches covered.">		if (atan2 &lt; 0.0) {</span>
<span class="fc" id="L1454">			atan2 = Math.PI * 2 + atan2;</span>
		}

<span class="fc" id="L1457">		return atan2;</span>
	}


	/**
	 * Computes the angle3D between the positive x-axis and the point (to - (0,0)).
	 * Result is in interval (0,2*PI) according to standard math usage.
	 *
	 * @see &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;https://en.wikipedia.org/wiki/Atan2&lt;/a&gt;
	 * @param to   the second point / vector
	 *
	 * @return the angle3D between the positive x-axis and the vector ((0,0) -&gt; to)
	 */
	public static double angleTo(@NotNull final IPoint to) {
<span class="fc" id="L1471">		return angleTo(new VPoint(0,0), to);</span>
	}

	/**
	 * Returns the angle3D between two lines in clock wise order (cw).
	 *
	 * @param line1 the first line
	 * @param line2 the second line
	 *
	 * @return the angle3D between two lines in clock wise order (cw).
	 */
	public static double angleBetween2Lines(@NotNull final VLine line1, @NotNull final VLine line2)
	{
<span class="nc" id="L1484">		double angle1 = Math.atan2(line1.getY1() - line1.getY2(),</span>
<span class="nc" id="L1485">				line1.getX1() - line1.getX2());</span>
<span class="nc" id="L1486">		double angle2 = Math.atan2(line2.getY1() - line2.getY2(),</span>
<span class="nc" id="L1487">				line2.getX1() - line2.getX2());</span>
<span class="nc bnc" id="L1488" title="All 2 branches missed.">		return (angle1-angle2) &lt; 0 ? (angle1-angle2) + 2*Math.PI :(angle1-angle2);</span>
	}

	/**
	 * Computes a {@link VRectangle} square which is the tight bounding box of the collection of points.
	 *
	 * @param points    collection of points
	 * @param &lt;P&gt;       the type of the {@link IPoint}
	 *
	 * @return a square which is the tight bounding box of the collection of points
	 */
	public static &lt;P extends IPoint&gt; VRectangle bound(final Collection&lt;P&gt; points) {
<span class="nc" id="L1500">		return bound(points, 0.0);</span>
	}

	/**
	 * Computes a {@link VRectangle} square which is the tight bounding box of the collection of points.
	 * The bounding box is padded by &lt;tt&gt;padding&lt;/tt&gt;
	 *
	 * @param points    collection of points
	 * @param padding   the padding
	 * @param &lt;P&gt;       the type of the {@link IPoint}
	 *
	 * @return a square padded by &lt;tt&gt;padding&lt;/tt&gt; which is the tight bounding box of the collection of points
	 */
	public static &lt;P extends IPoint&gt; VRectangle bound(final Collection&lt;P&gt; points, final double padding) {
<span class="nc bnc" id="L1514" title="All 2 branches missed.">		if(points.isEmpty()) {</span>
<span class="nc" id="L1515">			throw new IllegalArgumentException(&quot;the point collection is empty.&quot;);</span>
		}

<span class="nc" id="L1518">		VPoint pMax = points.stream().map(p -&gt; new VPoint(p.getX(), p.getY())).reduce((p1, p2) -&gt; new VPoint(Math.max(p1.getX(), p2.getX()), Math.max(p1.getY(), p2.getY()))).get();</span>
<span class="nc" id="L1519">		VPoint pMin = points.stream().map(p -&gt; new VPoint(p.getX(), p.getY())).reduce((p1, p2) -&gt; new VPoint(Math.min(p1.getX(), p2.getX()), Math.min(p1.getY(), p2.getY()))).get();</span>

<span class="nc" id="L1521">		return new VRectangle(pMin.getX()-padding, pMin.getY()-padding, pMax.getX() - pMin.getX() + 2*padding, pMax.getY() - pMin.getY() + 2*padding);</span>
	}

	public static &lt;P extends IPoint&gt; VRectangle boundRelative(final Collection&lt;P&gt; points, final double persentage) {
<span class="nc bnc" id="L1525" title="All 2 branches missed.">		if(points.isEmpty()) {</span>
<span class="nc" id="L1526">			throw new IllegalArgumentException(&quot;the point collection is empty.&quot;);</span>
		}

<span class="nc" id="L1529">		VPoint pMax = points.stream().map(p -&gt; new VPoint(p.getX(), p.getY())).reduce((p1, p2) -&gt; new VPoint(Math.max(p1.getX(), p2.getX()), Math.max(p1.getY(), p2.getY()))).get();</span>
<span class="nc" id="L1530">		VPoint pMin = points.stream().map(p -&gt; new VPoint(p.getX(), p.getY())).reduce((p1, p2) -&gt; new VPoint(Math.min(p1.getX(), p2.getX()), Math.min(p1.getY(), p2.getY()))).get();</span>

<span class="nc" id="L1532">		double padding = Math.max(pMax.x - pMin.x, pMax.y - pMin.y) * persentage;</span>

<span class="nc" id="L1534">		return new VRectangle(pMin.getX()-padding, pMin.getY()-padding, pMax.getX() - pMin.getX() + 2*padding, pMax.getY() - pMin.getY() + 2*padding);</span>
	}

	public static &lt;P extends IPoint&gt; VRectangle boundRelativeSquared(final Collection&lt;P&gt; points, final double persentage) {
<span class="nc bnc" id="L1538" title="All 2 branches missed.">		if(points.isEmpty()) {</span>
<span class="nc" id="L1539">			throw new IllegalArgumentException(&quot;the point collection is empty.&quot;);</span>
		}

<span class="nc" id="L1542">		VPoint pMax = points.stream().map(p -&gt; new VPoint(p.getX(), p.getY())).reduce((p1, p2) -&gt; new VPoint(Math.max(p1.getX(), p2.getX()), Math.max(p1.getY(), p2.getY()))).get();</span>
<span class="nc" id="L1543">		VPoint pMin = points.stream().map(p -&gt; new VPoint(p.getX(), p.getY())).reduce((p1, p2) -&gt; new VPoint(Math.min(p1.getX(), p2.getX()), Math.min(p1.getY(), p2.getY()))).get();</span>

<span class="nc" id="L1545">		double max = Math.max(pMax.x - pMin.x, pMax.y - pMin.y);</span>

<span class="nc" id="L1547">		double padding = max * persentage;</span>

<span class="nc" id="L1549">		return new VRectangle(pMin.getX()-padding, pMin.getY()-padding, pMin.getX() + max + 2*padding, pMin.getY() + max + 2*padding);</span>
	}

	public static &lt;P extends IPoint&gt; VRectangle boundRelative(final Collection&lt;P&gt; points) {
<span class="nc" id="L1553">		return boundRelative(points, 0.01);</span>
	}

	/**
	 *  This method divides an non-acute triangle ACB into 7 acute triangles
	 *  &lt;ul&gt;
	 *      &lt;li&gt;AFE&lt;/li&gt;
	 *      &lt;li&gt;EFD&lt;/li&gt;
	 *      &lt;li&gt;DCE&lt;/li&gt;
	 *      &lt;li&gt;DHC&lt;/li&gt;
	 *      &lt;li&gt;DGH&lt;/li&gt;
	 *      &lt;li&gt;FGD&lt;/li&gt;
	 *      &lt;li&gt;GBH&lt;/li&gt;
	 *  &lt;/ul&gt;
	 *  If the triangle is non-acute at C. If the triangle is already acute the method returns the original triangle.
	 *  throws an illegal argument exception if the triangle is not a feasible triangle.
	 *
	 * @see &lt;a href=&quot;https://proofwiki.org/wiki/Obtuse_Triangle_Divided_into_Acute_Triangles&quot;&gt;https://proofwiki.org/wiki/Obtuse_Triangle_Divided_into_Acute_Triangles&lt;/a&gt;
	 * @param triangle the triangle which might be divided into 7 acute triangles
	 * @return if the triangle is acute this method returns it, otherwise it returns 7 acute triangles
	 */
	public static VTriangle[] generateAcuteTriangles(final VTriangle triangle) {
<span class="nc" id="L1575">		double angle1 = angle(triangle.p1, triangle.p2, triangle.p3);</span>
<span class="nc" id="L1576">		double angle2 = angle(triangle.p2, triangle.p3, triangle.p1);</span>
<span class="nc" id="L1577">		double angle3 = angle(triangle.p3, triangle.p1, triangle.p2);</span>
<span class="nc" id="L1578">		double tolerance = 0.000001;</span>

		// non-acute triangle
<span class="nc bnc" id="L1581" title="All 2 branches missed.">		if(triangle.isNonAcute()) {</span>
			VPoint c;
			VPoint a;
			VPoint b;
<span class="nc bnc" id="L1585" title="All 4 branches missed.">			if(angle1 &gt; angle2 &amp;&amp; angle1 &gt; angle3) {</span>
<span class="nc" id="L1586">				a = triangle.p3;</span>
<span class="nc" id="L1587">				c = triangle.p2;</span>
<span class="nc" id="L1588">				b = triangle.p1;</span>
			}
<span class="nc bnc" id="L1590" title="All 4 branches missed.">			else if(angle2 &gt; angle1 &amp;&amp; angle2 &gt; angle3) {</span>
<span class="nc" id="L1591">				a = triangle.p1;</span>
<span class="nc" id="L1592">				c = triangle.p3;</span>
<span class="nc" id="L1593">				b = triangle.p2;</span>
			}
<span class="nc bnc" id="L1595" title="All 4 branches missed.">			else if(angle3 &gt; angle1 &amp;&amp; angle3 &gt; angle2) {</span>
<span class="nc" id="L1596">				a = triangle.p2;</span>
<span class="nc" id="L1597">				c = triangle.p1;</span>
<span class="nc" id="L1598">				b = triangle.p3;</span>
			}
			else {
<span class="nc" id="L1601">				throw new IllegalArgumentException(triangle + &quot; is not a feasible triangle&quot;);</span>
			}

<span class="nc" id="L1604">			VPoint d = triangle.getIncenter();</span>
<span class="nc" id="L1605">			VCircle circle = new VCircle(d, d.distance(c));</span>
<span class="nc" id="L1606">			VPoint[] iPoints = intersection(new VLine(a, c), circle);</span>

<span class="nc bnc" id="L1608" title="All 2 branches missed.">			VPoint e = iPoints[0].equals(c, tolerance) ? iPoints[1] : iPoints[0];</span>
<span class="nc" id="L1609">			iPoints = intersection(new VLine(b, c), circle);</span>
<span class="nc bnc" id="L1610" title="All 2 branches missed.">			VPoint h = iPoints[0].equals(c, tolerance) ? iPoints[1] : iPoints[0];</span>

<span class="nc" id="L1612">			iPoints = intersection(new VLine(a, b), circle);</span>
<span class="nc bnc" id="L1613" title="All 2 branches missed.">			VPoint f = iPoints[0].distance(a) &lt; iPoints[1].distance(a) ? iPoints[0] : iPoints[1];</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">			VPoint g = iPoints[0].distance(a) &lt; iPoints[1].distance(a) ? iPoints[1] : iPoints[0];</span>

<span class="nc" id="L1616">			return new VTriangle[]{</span>
					new VTriangle(a, f, e),
					new VTriangle(e, f, d),
					new VTriangle(d, c, e),
					new VTriangle(d, h ,c),
					new VTriangle(d, g, h),
					new VTriangle(f, g, d),
					new VTriangle(g, b, h)
			};
		}
		else {
<span class="nc" id="L1627">			return new VTriangle[]{triangle};</span>
		}

	}

	/**
	 * Returns the {@link VPoint} p1+p2.
	 *
	 * @param p1 first point
	 * @param p2 second point
	 *
	 * @return p1+p2
	 */
	public static VPoint add(final VPoint p1, final VPoint p2) {
<span class="nc" id="L1641">		return new VPoint(p1.x + p2.x, p1.y + p2.y);</span>
	}

	/**
	 * Computes the quality smaller or equals one of the triangle with respect to the length of the edges,
	 * i.e. a triangle where each edge has equal length has the quality 1.
	 *
	 * @param triangle the triangle
	 *
	 * @return the quality smaller or equals one of the triangle
	 */
	public static double qualityOf(@NotNull final VTriangle triangle) {
<span class="nc" id="L1653">		return GeometryUtils.qualityInCircleOutCircle(triangle.p1, triangle.p2, triangle.p3);</span>
	}

	/**
	 * Computes the intersection point of two lines ((x1, y1), (x2, y2)) and ((x3, y3), (x4, y4)).
	 *
	 * Assumption: the lines are not co-linear.
	 *
	 * @param x1 x-coordinate of the first point of the first line
	 * @param y1 y-coordinate of the first point of the first line
	 * @param x2 x-coordinate of the second point of the first line
	 * @param y2 y-coordinate of the second point of the first line
	 * @param x3 x-coordinate of the first point of the second line
	 * @param y3 y-coordinate of the first point of the second line
	 * @param x4 x-coordinate of the second point of the second line
	 * @param y4 y-coordinate of the second point of the second line
	 *
	 * @return the intersection point of the two lines
	 */
	public static VPoint lineIntersectionPoint(final double x1,
											   final double y1,
											   final double x2,
											   final double y2,
											   final double x3,
											   final double y3,
											   final double x4,
											   final double y4) {
<span class="pc bpc" id="L1680" title="2 of 4 branches missed.">		assert new VLine(new VPoint(x1, y1), new VPoint(x2, y2)).intersectsLine(x3, y3, x4, y4);</span>
<span class="fc" id="L1681">		return intersectionPoint(x1, y1, x2, y2, x3, y3, x4, y4);</span>
		/*double d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
		assert d != 0;

		double x = ((x1 * y2 - y1 - x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d;
		double y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (y3 * y4 - y3 * x4)) / d;
		return new VPoint(x, y);*/
	}

	/**
	 * Computes the intersection point of two lines (p1, p2) and (q1, q2).
	 *
	 * Assumption: the lines are not co-linear.
	 *
	 * @param p1 first point of the first line
	 * @param p2 second point of the first line
	 * @param q1 first point of the second line
	 * @param q2 second point of the second line
	 *
	 * @return the intersection point of the two lines
	 */
	public static VPoint lineIntersectionPoint(final VPoint p1, final VPoint p2, final VPoint q1, final VPoint q2) {
<span class="fc" id="L1703">		return lineIntersectionPoint(p1.x, p1.y, p2.x, p2.y, q1.x, q1.y, q2.x, q2.y);</span>
	}

	/**
	 * Computes the intersection point of two &lt;tt&gt;line&lt;/tt&gt; and (q1, q2).
	 *
	 * Assumption: the lines are not co-linear.
	 *
	 * @param line  the first line
	 * @param x3    x-coordinate of the first point of the second line
	 * @param y3    y-coordinate of the first point of the second line
	 * @param x4    x-coordinate of the second point of the second line
	 * @param y4    y-coordinate of the second point of the second line
	 *
	 * @return the intersection point of the two lines
	 */
	public static VPoint lineIntersectionPoint(final VLine line,
											   final double x3,
											   final double y3,
											   final double x4,
											   final double y4) {
<span class="nc" id="L1724">		return lineIntersectionPoint(line.getX1(), line.getY1(), line.getX2(), line.getY2(), x3, y3, x4, y4);</span>
	}

	/**
	 * Computes the intersection point of two &lt;tt&gt;line1&lt;/tt&gt; and &lt;tt&gt;line2&lt;/tt&gt;.
	 *
	 * Assumption: the lines are not co-linear.
	 *
	 * @param line1 the first line
	 * @param line2 the second line
	 *
	 * @return the intersection point of the two lines
	 */
	public static VPoint lineIntersectionPoint(final VLine line1,
	                                           final VLine line2) {
<span class="nc" id="L1739">		return lineIntersectionPoint(line1.getX1(), line1.getY1(), line1.getX2(), line1.getY2(), line2.getX1(), line2.getY1(), line2.getX2(), line2.getY2());</span>
	}

	/**
	 * &lt;p&gt;A brute force method to get the set of all intersection points of a list of shapes.
	 * For two shapes this requires O(n * m) time where n, m are the number of points of the shapes.&lt;/p&gt;
	 *
	 * &lt;p&gt;Note: A sweepline algorithm could improve the performance significantly.&lt;/p&gt;
	 *
	 * @param shapes a list of shapes
	 * @return a set of intersection points
	 */
	public static Set&lt;VPoint&gt; getIntersectionPoints(@NotNull final List&lt;? extends VShape&gt; shapes) {
<span class="fc" id="L1752">		Set&lt;VPoint&gt; intersectionPoints = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L1753" title="All 2 branches covered.">		for(int i = 0; i &lt; shapes.size(); i++) {</span>
<span class="fc bfc" id="L1754" title="All 2 branches covered.">			for(int j = i + 1; j &lt; shapes.size(); j++) {</span>
<span class="fc" id="L1755">				List&lt;VPoint&gt; path1 = shapes.get(i).getPath();</span>
<span class="fc" id="L1756">				List&lt;VPoint&gt; path2 = shapes.get(j).getPath();</span>

<span class="fc bfc" id="L1758" title="All 2 branches covered.">				for(int ii = 0; ii &lt; path1.size(); ii++) {</span>
<span class="fc" id="L1759">					VPoint p1 = path1.get((ii) % path1.size());</span>
<span class="fc" id="L1760">					VPoint p2 = path1.get((ii + 1) % path1.size());</span>

<span class="fc bfc" id="L1762" title="All 2 branches covered.">					for(int jj = 0; jj &lt; path2.size(); jj++) {</span>
<span class="fc" id="L1763">						VPoint q1 = path2.get((jj) % path2.size());</span>
<span class="fc" id="L1764">						VPoint q2 = path2.get((jj + 1) % path2.size());</span>

<span class="fc bfc" id="L1766" title="All 2 branches covered.">						if(intersectLineSegment(p1, p2, q1, q2)) {</span>
<span class="fc" id="L1767">							VPoint intersectionPoint = GeometryUtils.lineIntersectionPoint(p1, p2, q1, q2);</span>
<span class="fc" id="L1768">							intersectionPoints.add(intersectionPoint);</span>
						}
					}

				}
			}
		}

<span class="fc" id="L1776">		return intersectionPoints;</span>
	}

	/**
	 * &lt;p&gt;Transforms a list of distinct points (p1,p2,p3,...,pn) into a polygon.&lt;/p&gt;
	 *
	 * &lt;p&gt;Assumption: the points are in the correct order i.e. ccw or cw. and the list contains
	 * more than 2 points.&lt;/p&gt;
	 *
	 * @param points a list of points in order
	 * @return a polygon which is constructed via a list of points
	 */
	public static VPolygon toPolygon(@NotNull final List&lt;? extends IPoint&gt; points) {
<span class="pc bpc" id="L1789" title="2 of 4 branches missed.">		assert points.size() &gt;= 3;</span>
<span class="pc bpc" id="L1790" title="1 of 2 branches missed.">		if(points.size() &lt; 3) {</span>
<span class="nc" id="L1791">			throw new IllegalArgumentException(&quot;more than 2 points are required to form a valid polygon.&quot;);</span>
		}
<span class="fc" id="L1793">		return polygonFromPoints2D(points);</span>
	}

	public static VPolygon toPolygon(final VCircle circle, final int nPoints) {
<span class="nc" id="L1797">		double alpha = 2 * Math.PI / nPoints;</span>
<span class="nc" id="L1798">		VPoint p = new VPoint(0, circle.getRadius());</span>

<span class="nc" id="L1800">		Path2D.Double path = new Path2D.Double();</span>
<span class="nc" id="L1801">		VPoint center = circle.getCenter();</span>

<span class="nc" id="L1803">		path.moveTo(center.x + p.x, center.y + p.y);</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">		for(int i = 1; i &lt; nPoints; i++) {</span>
<span class="nc" id="L1805">			p = p.rotate(alpha);</span>
<span class="nc" id="L1806">			path.lineTo(center.x + p.x, center.y + p.y);</span>
		}
<span class="nc" id="L1808">		return new VPolygon(path);</span>
	}

	/**
	 * Tests if two polygons are equals, i.e. they are defined by the same list of points.
	 * The list of the first polygon might be shifted and/or reversed with respect to the second polygon.
	 *
	 * @param poly1 the first polygon
	 * @param poly2 the second polygon
	 * @return true if both polygons are defined by the same path, false otherwise
	 */
	public static boolean equalsPolygons(@NotNull final VPolygon poly1, @NotNull final VPolygon poly2) {
<span class="nc bnc" id="L1820" title="All 4 branches missed.">		return equalsPolygonsInOrder(poly1, poly2) || equalsPolygonsInOrder(poly1.revertOrder(), poly2);</span>
	}

	/**
	 * Tests if two polygons are equals, i.e. they are defined by the same list of points.
	 * The list of the first polygon might be shifted with respect to the second polygon.
	 *
	 * @param poly1 the first polygon
	 * @param poly2 the second polygon
	 * @return true if both polygons are defined by the same path, false otherwise
	 */
	private static boolean equalsPolygonsInOrder(@NotNull final VPolygon poly1, @NotNull final VPolygon poly2) {
<span class="nc" id="L1832">		List&lt;VPoint&gt; pointList1 = poly1.getPoints();</span>
<span class="nc" id="L1833">		List&lt;VPoint&gt; pointList2 = poly2.getPoints();</span>

<span class="nc bnc" id="L1835" title="All 2 branches missed.">		if(pointList1.size() != pointList2.size()) {</span>
<span class="nc" id="L1836">			return false;</span>
		}

<span class="nc bnc" id="L1839" title="All 4 branches missed.">		if(pointList1.isEmpty() &amp;&amp; pointList2.isEmpty()) {</span>
<span class="nc" id="L1840">			return true;</span>
		}

<span class="nc" id="L1843">		boolean found = false;</span>
<span class="nc" id="L1844">		int j = -1;</span>
<span class="nc bnc" id="L1845" title="All 2 branches missed.">		for(int i = 0; i &lt; pointList1.size(); i++) {</span>
<span class="nc" id="L1846">			VPoint p0 = pointList2.get(0);</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">			if(p0.equals(pointList1.get(i))) {</span>
<span class="nc" id="L1848">				j = i;</span>
<span class="nc" id="L1849">				found = true;</span>
<span class="nc" id="L1850">				break;</span>
			}
		}

<span class="nc bnc" id="L1854" title="All 2 branches missed.">		if(!found) {</span>
<span class="nc" id="L1855">			return false;</span>
		}

<span class="nc bnc" id="L1858" title="All 2 branches missed.">		for(int i = 0; i &lt; pointList2.size(); i++) {</span>
<span class="nc bnc" id="L1859" title="All 2 branches missed.">			if(!pointList2.get(i).equals(pointList1.get((j+i) % pointList1.size()))) {</span>
<span class="nc" id="L1860">				return false;</span>
			}
		}

<span class="nc" id="L1864">		return true;</span>
	}

	/**
	 * &lt;p&gt;This method removes duplicated and co-linear points from a list (p1, ..., pn) of points which form a simple polygon.
	 * points p1, p2, p3 are seen as co-linear if the distance from p3 to line p1 to p2 is smaller or equals eps.&lt;/p&gt;
	 *
	 * &lt;p&gt;Assumption: p1 to ... to pn forms a simple polygon.&lt;/p&gt;
	 *
	 * @param points    points of a polygon.
	 * @param eps       the distance which determines if three points are co-linear
	 *
	 * @return a list of points forming a simple polygon such that there are no duplicated or co-linear points.
	 */
	public static List&lt;VPoint&gt; filterUselessPoints(@NotNull final List&lt;VPoint&gt; points, final double eps) {
<span class="nc bnc" id="L1879" title="All 4 branches missed.">		assert points.size() &gt;= 3;</span>
<span class="nc" id="L1880">		List&lt;VPoint&gt; filteredList = new ArrayList&lt;&gt;(points);</span>

		boolean removePoint;

		do {
<span class="nc" id="L1885">			removePoint = false;</span>
<span class="nc bnc" id="L1886" title="All 2 branches missed.">			for(int i = 0; i &lt; filteredList.size(); i++) {</span>

<span class="nc" id="L1888">				VPoint p1 = filteredList.get((i + filteredList.size()-1) % filteredList.size());</span>
<span class="nc" id="L1889">				VPoint p2 = filteredList.get(i);</span>
<span class="nc" id="L1890">				VPoint p3 = filteredList.get((i + 1) % filteredList.size());</span>

<span class="nc bnc" id="L1892" title="All 6 branches missed.">				if(p2.equals(p1) || p2.equals(p3) || GeometryUtils.distanceToLineSegment(p1, p3, p2) &lt;= eps) {</span>
<span class="nc" id="L1893">					filteredList.remove(i);</span>
<span class="nc" id="L1894">					removePoint = true;</span>
<span class="nc" id="L1895">					break;</span>
				}
			}
<span class="nc bnc" id="L1898" title="All 2 branches missed.">		} while (removePoint);</span>

<span class="nc" id="L1900">		return filteredList;</span>
	}

	/**
	 * Transforms a list of points into a simple polygon {@link VPolygon}.
	 *
	 * @param sorted if true the method assumes that the list of points is sorted i.e. forms already a valid simple polygon,
	 *               otherwise the list will be sorted in ccw order beforehand.
	 * @param points the list of points
	 * @return a simple polygon defined by the list of points
	 */
	public static VPolygon toPolygon(final boolean sorted, @NotNull final List&lt;IPoint&gt; points) {
<span class="nc bnc" id="L1912" title="All 4 branches missed.">		assert points.size() &gt;= 3;</span>
<span class="nc bnc" id="L1913" title="All 2 branches missed.">		return toPolygon(sorted ? points : sortCCW(points));</span>
	}

	/**
	 * Sorts a list of points in ccw order with respect to the centroid of the list of points.
	 *
	 * @param points the list of points
	 * @return a ccw sorted (with respect to the centroid of the points) list of the same points
	 */
	public static List&lt;IPoint&gt; sortCCW(@NotNull final List&lt;IPoint&gt; points) {
<span class="nc" id="L1923">		List&lt;IPoint&gt; sortedPoints = new ArrayList&lt;&gt;(points);</span>
<span class="nc" id="L1924">		VPoint center = getCentroid(points);</span>
<span class="nc" id="L1925">		Collections.sort(sortedPoints, new CCWComparator(center));</span>
<span class="nc" id="L1926">		return sortedPoints;</span>
	}

	/**
	 * Computes the centroid of an (unsorted) point set.
	 *
	 * @param points the point set (as list)
	 * @return the centroid of an (unsorted) point set
	 */
	public static VPoint getCentroid(@NotNull final List&lt;IPoint&gt; points) {
<span class="nc" id="L1936">		double x = 0;</span>
<span class="nc" id="L1937">		double y = 0;</span>
<span class="nc bnc" id="L1938" title="All 2 branches missed.">		for(IPoint p : points) {</span>
<span class="nc" id="L1939">			x += p.getX();</span>
<span class="nc" id="L1940">			y += p.getY();</span>
<span class="nc" id="L1941">		}</span>
<span class="nc" id="L1942">		return new VPoint(x / points.size(), y / points.size());</span>
	}

	/**
	 * &lt;p&gt;Transforms a list of distinct points (p1,p2,p3,...,pn) into a polygon.&lt;/p&gt;
	 *
	 * &lt;p&gt;Assumption: the points are in the correct order i.e. ccw or cw. and the list contains
	 * more than 2 points.&lt;/p&gt;
	 *
	 * @param points an array / list of points in order
	 * @return a polygon
	 */
	public static VPolygon toPolygon(@NotNull final IPoint ... points) {
<span class="pc bpc" id="L1955" title="2 of 4 branches missed.">		assert points.length &gt;= 3;</span>
<span class="pc bpc" id="L1956" title="1 of 2 branches missed.">		if(points.length &lt; 3) {</span>
<span class="nc" id="L1957">			throw new IllegalArgumentException(&quot;more than 2 points are required to form a valid polygon.&quot;);</span>
		}

<span class="fc" id="L1960">		Path2D path2D = new Path2D.Double();</span>
<span class="fc" id="L1961">		path2D.moveTo(points[0].getX(), points[0].getY());</span>
		//path2D.lineTo(points[0].getX(), points[0].getY());

<span class="fc bfc" id="L1964" title="All 2 branches covered.">		for(int i = 1; i &lt; points.length; i++) {</span>
<span class="fc" id="L1965">			path2D.lineTo(points[i].getX(), points[i].getY());</span>
		}

<span class="fc" id="L1968">		path2D.lineTo(points[0].getX(), points[0].getY());</span>

<span class="fc" id="L1970">		return new VPolygon(path2D);</span>
	}

	/**
	 * &lt;p&gt;Returns a point which lies inside the polygon&lt;/p&gt;
	 *
	 * Assumption: the polygon is a valid simple polygon!
	 *
	 * @param polygon
	 * @return a point which lies inside the polygon
	 */
	public static VPoint getInteriorPoint(@NotNull final VPolygon polygon) {
		// for a convex polygon the centroid is a valid point
<span class="nc bnc" id="L1983" title="All 2 branches missed.">		if(polygon.contains(polygon.getCentroid())) {</span>
<span class="nc" id="L1984">			return polygon.getCentroid();</span>
		}

<span class="nc" id="L1987">		int maxTrys = 31; // for 32 bit integer</span>
<span class="nc" id="L1988">		double factor = 100;</span>
<span class="nc" id="L1989">		double minLineLength = polygon.getLinePath().stream().map(line -&gt; line.length()).min(Double::compareTo).get();</span>
<span class="nc" id="L1990">		Rectangle2D rectangle2D = polygon.getBounds2D();</span>

<span class="nc bnc" id="L1992" title="All 2 branches missed.">		for(int i = 1; i &lt; maxTrys; i++){</span>
<span class="nc" id="L1993">			double eps = Math.min(Math.min(rectangle2D.getWidth(), rectangle2D.getHeight()), minLineLength) / (factor * ((1 &lt;&lt; i)-1));</span>
<span class="nc bnc" id="L1994" title="All 2 branches missed.">			for(double x = rectangle2D.getX()+eps; x &lt; rectangle2D.getX()+rectangle2D.getWidth(); x+=eps) {</span>
<span class="nc bnc" id="L1995" title="All 2 branches missed.">				for(double y = rectangle2D.getY()+eps; y &lt; rectangle2D.getY()+rectangle2D.getHeight(); y+=eps) {</span>
<span class="nc" id="L1996">					VPoint p = new VPoint(x, y);</span>
<span class="nc bnc" id="L1997" title="All 2 branches missed.">					if(polygon.contains(p)) {</span>
<span class="nc" id="L1998">						return p;</span>
					}
				}
			}
		}

<span class="nc" id="L2004">		throw new IllegalArgumentException(&quot;unable to find an interior point for the polygon &quot; + polygon);</span>
	}

	/**
	 * Computes the projection of a onto b.
	 * See: https://en.wikipedia.org/wiki/Vector_projection
	 *
	 * @param ax x-coordinate of a
	 * @param ay y-coordinate of a
	 * @param bx x-coordinate of b
	 * @param by y-coordinate of b
	 * @return the projection of a onto b
	 */
	public static VPoint projectOnto(double ax, double ay, double bx, double by) {
<span class="pc bpc" id="L2018" title="2 of 4 branches missed.">		assert bx * bx + by * by &gt; GeometryUtils.DOUBLE_EPS;</span>
<span class="fc" id="L2019">		double blen = Math.sqrt(bx * bx + by * by);</span>
<span class="fc" id="L2020">		double bxn = bx / blen;</span>
<span class="fc" id="L2021">		double byn = by / blen;</span>

		// scalar product
<span class="fc" id="L2024">		double alpha = ax * bxn + ay * byn;</span>
<span class="fc" id="L2025">		VPoint a1 = new VPoint(bxn * alpha, byn * alpha);</span>
<span class="fc" id="L2026">		return a1;</span>
	}

	/**
	 * Projects the point (qx, qy) onto the line defined by (p0 = (p0x, p0y), p1 = (p1x, p1y)).
	 * see https://cs.nyu.edu/~yap/classes/visual/03s/hw/h2/math.pdf
	 *
	 * @param qx x-coordinate of a
	 * @param qy y-coordinate of a
	 * @param p0x x-coordinate of p0
	 * @param p0y y-coordinate of p0
	 * @param p1x x-coordinate of p1
	 * @param p1y y-coordinate of p1
	 *
	 * @return he projection of a onto the line (p,q)
	 */
	public static VPoint projectOntoLine(double qx, double qy, double p0x, double p0y, double p1x, double p1y) {
<span class="fc" id="L2043">		double ax11 = p1x - p0x;</span>
<span class="fc" id="L2044">		double ax12 = p1y - p0y;</span>
<span class="fc" id="L2045">		double ax21 = p0y - p1y;</span>
<span class="fc" id="L2046">		double ax22 = p1x - p0x;</span>
<span class="fc" id="L2047">		double bx1 = qx * (p1x - p0x) + qy * (p1y - p0y);</span>
<span class="fc" id="L2048">		double bx2 = p0y * (p1x - p0x) - p0x * (p1y - p0y);</span>
<span class="fc" id="L2049">		double det = (ax11 * ax22 - ax12 * ax21);</span>

<span class="fc" id="L2051">		double px1 = (ax22 * bx1 - ax12 * bx2) / det;</span>
<span class="fc" id="L2052">		double px2 = (-ax21 * bx1 + ax11 * bx2) / det;</span>
<span class="fc" id="L2053">		return new VPoint(px1, px2);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>